%%
%% Author: Clay
%% 2020/12/22
%%

\section{位置无关代码}
{
    可以加载而无需重定位的代码称为\emreg{位置无关代码(Position=Independent Code, PIC)}。

    在一个x86-64系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为PIC。
    可以用PC相对寻址来编译这些引用，够造目标文件时由静态链接器重定位。

    \subsection{PIC数据引用}
    {
        无论在内存中的何处 加载一个目标模块，数据的与代码段的距离总是保持不变。
        代码段中任何指令和数据段中任何变量之间的\emreg{距离}都是一个运行时常量，与代码段和数据段的绝对位置是无关的。

        想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做\emreg{全局偏移量表(Global Offset Table, GOT)}。
        在GOT中，每个被这个目标模块引用的全局数据目标都有一个8字节条目。
        编译器还为GOT中每个条目生成一个重定位记录。
        在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。
        每个引用全局目标的目标模块都有自己的GOT。
    }

    \subsection{PIC函数调用}
    {
        假设程序调用一个由共享库定义的函数。
        编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块可以加载到任意位置。
        正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。
        这种方法并不是PIC，因为它需要链接器修改调用模块的代码段。
        GNU编译系统使用了一种很有趣的技术来解决这个问题，称为\emreg{延迟绑定(binding)}，将过程地址的绑定推迟到第一次调用该过程时。

        \begin{description}
            \item[过程链接表(PLT)]
            {
                PLT是一个数组，其中每个条目是16字节代码。
                PLT[0]是一个特殊条目，它跳转到动态链接器中。
                每个被可执行的程序调用的库函数都有它自己的PLT条目。
                每个条目都负责调用一个具体的函数。
            }
            \item[全局偏移量表(GOT)]
            {
                GOT是一个数组，其中每个条目是8字节地址。
            }
        \end{description}

        在函数第一次被调用时，延迟解析它的运行时地址：

        \begin{enumerate}
            \item 不调用函数，程序调用进入PLT。
            \item 第一条PLT指令通过GOT进行间接跳转。
            \item 把函数的ID压入栈中之后，PLT跳转。
            \item
            {
                通过GOT间接地把动态链接器的一个参数压入栈中，通过GOT间接跳转进动态链接器中。
                动态链接器使用两个栈条目来确定函数的运行时位置，用这个地址重写GOT，再把控制传递给函数。
            }
        \end{enumerate}

        后续再调用函数时的控制流：

        \begin{enumerate}
            \item 控制传递到PLT。
            \item 通过GOT的间接跳转会将控制直接转移到函数。
        \end{enumerate}
    }
}
