%%
%% Author: Clay
%% 2020/12/22
%%

\section{重定位}
{
    重定位由两部组成：

    \begin{description}
        \item[重定位节和符号定义]
        {
            链接器将所有相同类型的节合并为同一类型的新的聚合节。
            然后链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。
            当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。
        }
        \item[重定位节中的符号引用]
        {
            链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。
            链接器依赖于可重定位目标模块中称为\emspe{重定位条目(relocation entry)}的数据结构。
        }
    \end{description}

    \subsection{重定位条目}
    {
        汇编器遇到对最终位置位置的目标引用，它就会生成一个\emreg{重定位条目}，告诉连接器在将目标文件合并成可执行文件时如何修改这个引用。
        代码的重定位条目放在.rel.text中。
        已初始化数据的重定位条目放在.rel.data中。

        ELF定义了32中不同的从定位类型。

        \begin{description}
            \item[R_X86-64_PC32]
            {
                重定位使用一个使用32位PC相对地址的引用。
                当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到\emspe{有效地址}。
            }
            \item[R_X86_64_32]
            {
                重定位一个使用32位绝对地址的引用。
                通过绝对地址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。
            }
        \end{description}

        这两种重定位类型支持x86-64\emreg{小型代码模型(small code model)}，该模型假设可执行目标文件中的代码和数据的总体大小小于2GB。
    }

    \subsection{重定位符号引用}
    {
        %4.
        \begin{practicec}
            \begin{enumerate}[A.]
                \item 4004df
                \item 0x5
            \end{enumerate}
        \end{practicec}

        %5.
        \begin{practicec}
            10
        \end{practicec}
    }
}
