%%
%% Author: Clay
%% 2020/12/23
%%

\section{异常}
{
    异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。

    \emreg{异常(exception)}就是控制流中的突变，用来响应处理器状态中的某些变化。

    当处理器\emreg{状态}中发生一个重要的变化时，状态被编码为不同的位和信号。
    状态变化称为\emreg{事件(event)}。

    在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做\emreg{异常表(exception table)}的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子程序（\emreg{异常处理程序(exception handler)}）。
    当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况中的一种：

    \begin{itemize}
        \item 处理程序将控制返回给当前指令
        \item 处理器将控制返回给下一条指令
        \item 处理程序终止被中断的程序
    \end{itemize}

    \subsection{异常处理}
    {
        系统中可能的每种类型的异常都分配了一个唯一的非负整数的\emreg{异常号(exception number)}。

        在系统启动时，操作系统分配和初始化一张称为\emreg{异常表}的跳转表，使得表目 $k$ 包含异常 $k$ 的处理程序的地址。

        处理器检测到发生了一个事件，并且确定了相应的异常号 $k$ 。
        随后，处理器触发异常，方法是执行简介过程调用。
        异常号只是异常表中的索引，异常表的起始地址放在一个叫做\emreg{异常表基址寄存器(exception table base register)}的特殊CPU寄存器那里。

        异常类似于过程调用，但有一些重要的不同之处：

        \begin{itemize}
            \item 根据异常的类型，返回地址要么是当前指令，要么是下一条指令。
            \item 处理器也把一些额外的处理器状态压到栈里。
            \item 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。
            \item 异常处理程序运行在\emreg{内核模式下}。
        \end{itemize}
    }

    \subsection{异常的类别}
    {
        异常可以分为四类：
        \emreg{中断(interrupt)}、\emreg{陷阱(trap)}、\emreg{故障(fault)}和\emreg{终止(abort)}。

        \begin{table}[htb]
            \centering

            \caption{异常的类别}

            \begin{tabular}{|c|c|c|c|c}
                \hline
                类别 & 原因 & 异步/同步 & 返回行为 \\
                \hline
                中断 & 来自I/O设备的信号 & 异步 & 总是返回到下一条指令 \\
                \hline
                陷阱 & 有意的异常 & 同步 & 总是返回到下一条指令 \\
                \hline
                故障 & 潜在可恢复的错误 & 同步 & 可能返回到当前指令 \\
                \hline
                终止 & 不可恢复的错误 & 同步 & 不会返回 \\
                \hline
            \end{tabular}
        \end{table}

        \subsubsection{中断}
        {
            \emreg{中断}是异步发生的，是来自处理器外部的I/O设备的信号的结果。
            硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。
            硬件中断的异常处理程序常常称为\emreg{中断处理程序(interrupt handler)}。

            在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。
            当处理程序返回时，它就将控制返回给下一条指令。

            剩下的异常类型是同步发生的，是执行当前指令的结果，这类指令叫做\emreg{故障指令(faulting instruction)}。
        }

        \subsubsection{陷阱和系统调用}
        {
            陷阱是\emreg{有意}的异常，是执行一条指令的结果。
            陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做\emreg{系统调用}。
        }

        \subsubsection{故障}
        {
            故障由错误情况引起，它可能能够被故障处理程序修正。
            如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。
            否则，处理程序返回到内核中的abort例程。
        }

        \subsubsection{终止}
        {
            终止是不可恢复的致命错误造成的结果，通常试一些硬件错误。
            终止处理程序从不将控制返回给应用程序。
        }
    }

    \subsection{Linux/X86\_64系统中的异常}
    {
        \subsubsection{Linux/X86\_64故障和终止}
        {
            \emreg{除法错误}。
            当应用试图除以0时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误。

            \emreg{一般保护故障}
            许多原因都会导致不为人知的一般保护故障，通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。

            \emreg{缺页}是会重新执行产生故障的指令的一个异常示例。
            处理程序将适当的磁盘上的虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。

            \emreg{机器检查}
            机器检查是在导致故障的指令执行中检测到致命的硬件错误时发生的。
        }
    }
}
