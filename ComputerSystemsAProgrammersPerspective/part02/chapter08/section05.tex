%%
%% Author: Clay
%% 2021/1/14
%%

\section{信号}
{
    \emreg{Linux信号}允许进程和内核中断其它进程。

    一个\emreg{信号}就是一条小消息，它通知进程系统中发生了一个某种类型的事件。

    底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。
    信号提供了一种机制，通知用户进程发生了异常。

    \subsection{信号术语}
    {
        传送一个信号到目的进程是由两个不同步骤组成的：

        \begin{description}
            \item[发送信号]
            {
                内核通过更新目的进程上下文中的某个状态，\emspe{发送（递送）}一个信号给目的进程。
                发送信号可以有如下两种原因：
                内核检测到一个系统事件。
                一个进程调用了kill函数，显示地要求内核发送一个信号给目的进程。
                一个进程可以发送信号给它自己。
            }
            \item[接收信号]
            {
                当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就\emspe{接收}了信号。
                进程可以忽略这个信号，终止或者通过执行一个称为\emspe{信号处理程序(signal handler)}的用户层函数\emspe{捕获}这个信号。
            }
        \end{description}

        一个发出而没有被接受的信号叫做\emreg{待处理信号(pending signal)}。
        在任何时刻，一种类型至多只会有一个待处理信号。
        如果一个进程有一个类型为k的待处理信号，那么接下来发送到这个进程的类型为k的信号都\emreg{不会}排队等待，它们只是被简单地丢弃。
        一个进程可以有选择地\emreg{阻塞某种信号}。
        当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。

        一个待处理信号最多只能被接受一次。
    }

    \subsection{发送信号}
    {
        Unix系统提供了大量向进程发送信号的机制。
        所有这些机制都是基于\emreg{进程组(process group)}这个概念的。

        \subsubsection{进程组}
        {
            每个进程都只属于一个\emreg{进程组}，进程组是由一个正整数\emreg{进程组ID}来标识的。

            默认地，一个子进程和它的父进程属于一个进程组。
        }

        \subsubsection{用/bin/kill程序发送信号}
        {
            /bin/kill程序可以向另外的进程发送任意的信号。

            一个为负的pid会导致信号被发送到进程组PID中的每个进程。
        }

        \subsubsection{从键盘发送信号}
        {
            Unix shell使用\emreg{作业(job)}这个抽象概念来表示为对一条命令行求值而创建的进程。
            在任何时刻，至多只有一个前台作业和0个或多个后台作业。
        }

        \subsubsection{用kill函数发送信号}
        {
            进程通过调用kill函数发送给信号给其他进程。
        }

        \subsubsection{用alarm函数发送信号}
        {
            进程可以通过调用alarm函数向它自己发送SIGALRM信号。
        }
    }

    \subsection{接收信号}
    {
        当内核把进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞的待处理信号的集合。
        如果这个集合是非空的，那么内核选择集合中的某个信号k，并强制p\emreg{接收}信号k。
        每个信号类型都有一个预定义的\emreg{默认行为}，是下面的一种：

        \begin{itemize}
            \item 进程终止。
            \item 进程终止并转储内存。
            \item 进程停止直到被SIGCONT信号重启。
            \item 进程忽略该信号。
        \end{itemize}

        进程可以通过signal函数修改和信号相关联的默认行为。
        唯一的例外是SIGSTOP和SIGKILL，它们的默认行为是不能修改的。

        signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为。

        \begin{itemize}
            \item 如果handler是SIG_IGN，那么忽略信号。
            \item 如果handler是SIG_DEL，那么恢复默认行为。
            \item
            {
                否则，handler就是用户定义的函数的地址，这个函数被称为\emreg{信号处理程序}，只要进程接收到一个类型为signum的信号，就会调用这个程序。
                通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做\emreg{设置信号处理程序(installing the handler)}。
                调用信号处理程序称为\emreg{捕获信号}。
                执行信号处理程序称为\emreg{处理信号}。
            }
        \end{itemize}

        当一个进程捕获了一个类型为k的信号时，会调用为信号k设置的处理程序，一个整数参数被设置为k，这个参数允许同一个处理函数捕获不同类型的信号。

        当处理程序执行它的return语句时，控制通常传递回控制流中进程信号接收中断位置处的指令。

        信号处理程序可以被其他信号处理程序中断。

        %7.
        \begin{practicec}

        \end{practicec}
    }

    \subsection{阻塞和解除阻塞信号}
    {
        Linux提供阻塞信号的隐式和显式的机制：

        \begin{description}
            \item[隐式阻塞机制] 内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。
            \item[显示阻塞机制] 应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。
        \end{description}
    }

    \subsection{编写信号处理程序}
    {
        处理程序有几个属性使得它们很难推理分析：
        处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他的处理程序互相干扰。
        如何以及何时接收信号的规则常常有违人的直觉。
        不同的系统有不同的信号处理语义。

        \subsubsection{安全的信号处理}
        {
            一些保守的编写处理程序的原则，使得这些处理程序能安全地并发运行。

            \begin{description}
                \item[处理程序要尽可能简单] 避免麻烦的最好方法是保持处理程序尽可能小和简单。
                \item[在处理程序中只调用异步信号安全的函数]
                {
                    所谓\emspe{异步信号安全}的函数能够被信号处理程序安全地调用，原因有二：
                    要么它是\emreg{可重入的}，要么它不能被信号处理程序中断。

                    信号处理程序中产生输出唯一安全的方法是使用write函数。
                }
                \item[保存和恢复errno] 只有在处理程序要返回时才有必要。
                \item[阻塞所有的信号，保护对共享全局数据结构的访问]
                \item[用volatile声明全局变量] 用volatile类型限定符来定义一个变量，告诉编译器不要缓存这个变量。
                \item[用sig_atomic_t声明标志] C提供一种整型数据类型，对它的读和写保证会是原子的。
            \end{description}
        }

        \subsubsection{正确的信号处理}
        {
            信号的一个与直觉不服的方面是未处理的信号是不排队的，因为pending位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。
            如果存在一个未处理的信号就表明\emreg{至少}有一个信号到达了。

            父进程必须回收子进程以避免在系统中留下僵死进程。

            \emreg{不可以用信号来对其他进程中发生的事件计数}。

            %8.
            \begin{practicec}
                213
            \end{practicec}
        }

        \subsubsection{可移植的信号处理}
        {
            Unix信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。

            \begin{description}
                \item[signal函数的语义各有不同]
                {
                    有些老的Unix系统在信号k被处理程序捕获之后就把对信号k的反应恢复到默认值。
                }
                \item[系统调用可以被中断]
                {
                    像read、write和accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为\emreg{慢速系统调用}。
                }
            \end{description}

            Posix标准定义了sigaction函数，允许用户在设置信号处理时，明确指定他们想要的信号处理语义。
        }
    }

    \subsection{同步流以避免讨厌的并发错误}
    {
        流可能交错的数量与指令的数量呈指数关系。
        基本的问题是以某种方式\emreg{同步}并发流，从而得到的最大的可行的交错的集合，每个可行的交错都能得到正确的结果。

        子进程继承了他们父进程的被阻塞集合。
    }
}
