%%
%% Author: Clay
%% 2021/2/18
%%

\section{虚拟内存作为缓存的工具}
{
    虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。
    每个字节都有一个唯一的虚拟地址，作为数组的索引。
    磁盘上数组的内容被缓存在主存中。
    和存储器层次结构中其他缓存一样，磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。
    VM系统通过将虚拟内存分割为\emreg{虚拟页(Virtual Page, VP)}的大小固定的块来处理这个问题。
    每个虚拟页的大小为 $P = 2^p$ 字节。
    类似地，物理内存被分割为\emreg{物理页(Physical Page, PP)}，大小也为 $P$ 字节（物理页也被称为\emreg{页帧(page frame)}）。

    在任意时刻，虚拟页面的集合都分为三个不相交的子集：

    \begin{description}
        \item[未分配的] VM系统还未分配（或者创建）的页。
        \item[缓存的] 当前已缓存在物理内存中的已分配页。
        \item[未缓存的] 未缓存在物理内存中的已分配页。
    \end{description}

    \subsection{DRAM缓存的组织结构}
    {
        使用术语\emreg{SRAM缓存}标识位于CPU和主存之间的L1、L2和L3高速缓存，并且用术语\emreg{DRAM缓存}来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。

        因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是\emreg{4KB~2MB}。
        由于大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何物理页中。
        不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常之高。
        因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。
    }

    \subsection{页表}
    {
        同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。
        如果是，系统还必须确定这个虚拟页放在哪个物理页中。
        如果不命中，系统必须判断这个虚拟页放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。

        这些功能是由软硬件联合提供的，包括操作系统软件、MMU中的地址翻译硬件和一个存放在物理内存中叫做\emreg{页表(page table)}的数据结构，页表将虚拟页映射到物理页。
        每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。
        操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。

        页表就是一个\emreg{页表条目(Page Table Entry, PTE)}的数组。
        虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。
        假设每个PTE是由一个\emreg{有效位(valid bit)}和一个 $n$ 位地址字段组成的。
        有效位表明了该虚拟页当前是否被缓存在DRAM中。

        因为DRAM缓存是全相联的，所以任意物理页都可以包含任意虚拟页。

        %2.
        \begin{practicec}
            \begin{table}
                \[
                    \begin{array}{|c|c|c|}
                        \hline
                        n & P = 2^p & \text{PTE数量} \\
                        \hline
                        16 & 4K & 16 \\
                        \hline
                        16 & 8K & 8 \\
                        \hline
                        32 & 4K & 1M \\
                        \hline
                        32 & 8K & 512K \\
                        \hline
                    \end{array}
                \]
            \end{table}
        \end{practicec}
    }

    \subsection{页命中}
    {
        因为设置了有效位，那么地址翻译使用PTE中的物理内存地址，构造出物理地址。
    }

    \subsection{缺页}
    {
        在虚拟内存的习惯说法中，DRAM缓存不命中称为\emreg{缺页(page fault)}。
        地址翻译硬件从内存中读取PTE，从有效位推断出该页未被缓存，并且触发一个缺页异常。
        缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。

        接下来，内核从磁盘复制到内存，更新PTE，随后返回。
        当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。

        在虚拟内存的习惯说法中，块被称为页。
        在磁盘和内存之间传送页的活动叫做\emreg{交换(swapping)}或者\emreg{页面调度(paging)}。
        页从磁盘\emreg{换入}（或者\emreg{页面调入}）DRAM和从DRAM\emreg{换出}（或者\emreg{页面调出}）磁盘。
        当有不命中发生时，才换入页面的这种策略称为\emreg{按需页面调度(demand paging)}。
    }

    \subsection{分配页面}
    {
        分配过程是在磁盘上创建空间并更新PTE。
    }

    \subsection{又是局部性救了我们}
    {
        虚拟内存工作得相当好，这要归功于\emreg{局部性(locality)}。

        尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的\emreg{活动页面(active page)}集合上工作，这个集合叫做\emreg{工作集(working set)}或者\emreg{常驻集合(resident set)}。
        在将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。

        只要我们的程序有好的时间局部性，虚拟内存系统就能工作得相当好。
        如果工作集的大小超出了物理量内存的大小，那么程序将产生一种不幸的状态，叫做\emreg{抖动(thrashing)}，这时页面将不断地换进换出。
    }
}
