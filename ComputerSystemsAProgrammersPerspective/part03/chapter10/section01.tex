%%
%% Author: Clay
%% 2021/2/19
%%

\section{Unix I/O}
{
    一个\emreg{Linux文件}就是一个 $m$ 个字节的序列。

    所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读写来执行。
    这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：

    \begin{description}
        \item[打开文件]
        {
            一个应用程序通过要求打开相应的文件，来宣告它想要访问一个I/O设备。
            内核返回一个非常小的非负整数，叫做\emspe{描述符}，它在后续对此文件的所有操作中标识这个文件。
            内核记录有关这个打开文件的所有信息。
            应用程序只需记住这个描述符。
        }
        \item[Linux shell 创建的每个进程开始时都有三个打开的文件] \emspe{标准输入(0)}、\emspe{标准输出(1)}和\emspe{标准错误(2)}。
        \item[改变当前的文件位置]
        {
            对于每个打开的文件，内核保持着一个\emspe{文件位置 $k$ }，初始为0。
            这个文件位置是从文件开头起始的字节偏移量。
            应用程序能够通过执行seek操作，显示地设置文件的当前位置为 $k$ 。
        }
        \item[读写文件]
        {
            一个\emspe{读}操作就是文件复制 $n$ 个字节到内存，从当前文件位置 $k$ 开始，然后将 $k$ 增加到 $k+n$ 。
            给定一个大小为 $m$ 字节的文件，当 $k \ge m$ 时执行读操作会触发一个称为\emspe{end-of-file(EOF)}的条件，应用程序能检测到这个条件。
            类似地，写操作就是从内存复制 $n$ 个字节到一个文件。
        }
        \item[关闭文件]
        {
            当应用完成了对文件的访问之后，它就通知内核\emspe{关闭}这个文件。
            作为响应，内核释放文件打开时创建的数据结构。
            无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。
        }
    \end{description}
}
