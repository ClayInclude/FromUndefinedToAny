%%
%% Author: Clay
%% 2020/2/21
%%

\section{信息存储}
{
    大多数计算机使用8位的块，或者\emreg{字节(byte)}，作为最小的可寻址的内存单位，而不是访问内存中单独的位。
    机器级程序将内存视为一个非常大的字节数组，称为\emreg{虚拟内存(virtual memory)}。
    内存的每个字节都由一个唯一的数字来标识，称为它的\emreg{地址(address)}，所有可能地址的集合就称为\emreg{虚拟地址空间(virtual address space)}。

    编译器和运行时系统将存储器空间划分为更可管理的单元，来存放不同的\emreg{程序对象(program object)}。

    \subsection{十六进制表示法}
    {
        \emreg{十六进制(hexadecimal, hex)}使用数字 $0 \sim 9$ 和字符 $A \sim F$ 来表示16个可能的值。

        通过展开每个十六进制数字，将它转换为二进制格式。

        如果给定一个二进制数字，可以通过把它分为每4位一组来转换为十六进制。
        如果位总数不是4的倍数，最左边的一组可以少于4位，前面用0补足。

        %1.
        \begin{practicec}
            \begin{enumerate}[A.]
                \item $11 1001 1010 0111 1111 1000$
                \item $0xC97A$
                \item $1101 0101 1110 0100 1100$
                \item $0x26E7B5$
            \end{enumerate}
        \end{practicec}

        当值 $x = 2^n$ 时， $x$ 的二进制表示就是 $1$ 后面跟 $n$ 个 $0$ 。
        十六进制数字 $0$ 代表 4个二进制 $0$ 。
        所以当 $n$ 表示成 $i + 4j$ 的形式，其中 $0 \leq i \leq 3$ ，可以把 $x$ 写为开头的十六进制数字为 $1(i = 0), 2(i = 1), 4(i = 2), 8(i = 3)$ ，后面紧跟 $j$ 个十六进制的 $0$ 。

        %2.
        \begin{practicec}
            \begin{table}[H]
                \[
                    \begin{array}{|c|c|c|}
                        \hline
                        n & 2^n \text{（十进制）} & 2^n \text{（十六进制）} \\
                        \hline
                        9 & 512 & 0x200 \\
                        \hline
                        19 & 524288 & 0x80000 \\
                        \hline
                        14 & 16384 & 0x4000 \\
                        \hline
                        16 & 65536 & 0x10000 \\
                        \hline
                        17 & 131072 & 0x20000 \\
                        \hline
                        5 & 32 & 0x20 \\
                        \hline
                        7 & 128 & 0x80 \\
                        \hline
                    \end{array}
                \]
            \end{table}
        \end{practicec}

        将一个十进制数字 $x$ 转换为十六进制，可以反复地用 $16$ 除 $x$ ，得到一个商 $q$ 和一个余数 $r$ ，也就是 $x = q \cdot 16 + r$ 。
        然后用十六进制数字表示的 $r$ 作为最低为数字，并通过对 $q$ 反复进行这个过程得到剩下的数字。

        将一个十六进制数字转换为十进制数字，可以用相应的 $16$ 的幂乘以每个十六进制数字。

        %3.
        \begin{practicec}
            \begin{table}[H]
                \[
                    \begin{array}{|c|c|c|}
                        \hline
                        \text{十进制} & \text{二进制} & \text{十六进制} \\
                        \hline
                        0 & 0000 0000 & 0x00 \\
                        \hline
                        167 & 1010 0111 & A7 \\
                        \hline
                        62 & 0011 1110 & 3E \\
                        \hline
                        188 & 1011 1100 & BC \\
                        \hline
                        55 & 0011 0111 & 37 \\
                        \hline
                        136 & 1000 1000 & 88 \\
                        \hline
                        243 & 1111 0011 & F3 \\
                        \hline
                        82 & 0101 0010 & 0x52 \\
                        \hline
                        172 & 1010 1100 & 0xAC \\
                        \hline
                        231 & 1110 0111 & 0xE7 \\
                        \hline
                    \end{array}
                \]
            \end{table}
        \end{practicec}

        %4.
        \begin{practicec}
            \begin{enumerate}[A.]
                \item $0x5044$
                \item $0x4FFC$
                \item $0x50A0$
                \item $0x9E$
            \end{enumerate}
        \end{practicec}
    }

    \subsection{字数据大小}
    {
        每台计算机都有一个\emreg{字长(word size)}，指明指针数据的\emreg{标称大小(nominal size)}。
        对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0 \sim 2^w - 1$ ，程序最多访问 $2^w$ 个字节。

        整数或者为\emreg{有符号的}，即可以表示负数、零和正数；
        或者为\emreg{无符号的}，即只能表示非负数。
    }

    \subsection{寻址和字节顺序}
    {
        在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

        考虑一个 $w$ 位的整数，其表示为 $[x_{w - 1}, x_{w - 2}, \cdots, x_1, x_0]$ ，其中 $x_{w - 1}$ 是最高有效位，而 $x_0$ 是最低有效位。
        假设 $w$ 是 $8$ 的倍数，这样这些位就能被分组成为字节。
        某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。
        前一种规则称为\emreg{小端法(little endian)}，后一种规则称为\emreg{大端法(big endian)}。

        有时候，字节序会成为问题。

        \begin{enumerate}
            \item
            {
                首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端机器或者反过来时，接收程序会发现，字里的字节成了反序的。
            }
            \item
            {
                第二种情况时，当阅读表示整数数据的字节序列时字节顺序也很重要。
            }
            \item
            {
                第三种情况是当编写规避正常的类型系统的程序时。
            }
        \end{enumerate}
    }
}
