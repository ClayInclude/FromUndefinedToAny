%%
%% Author: Clay
%% 2020/6/19
%%

\section{存储器层次结构}
{
    存储技术和计算机软件的一些基本的和持久的属性：

    \begin{description}
        \item[存储技术] 不同存储技术的访问时间差异很大。CPU和主存之间的速度差距在增大。
        \item[计算机软件] 一个编写良好的程序倾向于展示出良好的局部性。
    \end{description}

    硬件和软件的这些基本属性互相补充的很完美。
    他们这种相互补充的性质使人想到一种组织存储器系统的方法，称为\emreg{存储器层次结构(memory hierarchy)}。

    \subsection{存储器层次结构中的缓存}
    {
        \emreg{高速缓存(cache)}是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。
        使用高速缓存的过程称为\emreg{缓存(caching)}。

        存储器层次结构的中心思想是，对于每个 $k$ ，位于 $k$ 层的更快更小的存储设备作为 $k + 1$ 层的更大更慢的存储设备的缓存。
        换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。

        第 $k + 1$ 层的存储器被划分成连续的数据对象组块(chunk)，称为\emreg{块(block)}。

        类似地，第 $k$ 层的存储器被划分成较少的块的集合，每个块的大小与 $k + 1$ 层的块的大小一样。
        在任何时刻，第 $k$ 层的缓存包含第 $k + 1$ 层块的一个子集的副本。

        数据总是以块大小为\emreg{传送单元(transfer unit)}在第 $k$ 层和第 $k + 1$ 层来回复制的。
        虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的大小。
        一般而言，层次结构中较低层的设备的访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。

        \subsubsection{缓存命中}
        {
            当程序需要第 $k + 1$ 层中的某个数据对象 $d$ 时，它首先在当前存储在第 $k$ 层的一个块中查找 $d$ 。
            如果 $d$ 刚好缓存在第 $k$ 层中，那么就是我们所说的\emreg{缓存命中(cache hit)}。
        }

        \subsubsection{缓存不命中}
        {
            如果第 $k$ 层中没有缓存数据对象 $d$ ，那么就是\emreg{缓存不命中(cache miss)}。

            覆盖一个现存的块的过程称为\emreg{替换(replacing)}或\emreg{驱逐(evicting)}这个块。
            被驱逐的这个块有时也称为\emreg{牺牲块(victim block)}。
            决定该替换哪个块是由缓存的\emreg{替换策略(replacement policy)}来控制的。
        }

        \subsubsection{缓存不命中的种类}
        {
            如果第 $k$ 层的缓存是空的，那么对任何数据对象的访问都会不命中。
            一个空的缓存有时被称为\emreg{冷缓存(cold cache)}，此类不命中称为\emreg{强制性不命中(compulsory miss)}或\emreg{冷不命中(cold miss)}。
            冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得缓存\emreg{暖身(warmed up)}之后的稳定状态中出现。

            限制性的防治策略会引起一种不命中，称为\emreg{冲突不命中(conflict miss)}，在这种情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。

            程序通常是按照一系列阶段来运行的，每个阶段访问缓存块的某个相对稳定不变的集合。
            一个嵌套的循环可能会反复地访问同一个数组的元素，这个块的集合称为这个阶段的\emreg{工作集(working set)}。
            当工作集的大小超过缓存的大小时，缓存会经历\emreg{容量不命中(capacity miss)}.
        }

        \subsubsection{缓存管理}
        {
            存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。
            在每一层上，某种形式的逻辑必须\emreg{管理}缓存。
            某个东西要将缓存划分成块，在不同的层之间传送块，判定是命中还是不命中，并处理它们。
        }
    }

    \subsection{存储器层次结构概念小结}
    {
        基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：

        \begin{description}
            \item[利用时间局部性] 由于时间局部性，同一数据多项可能会被多次使用。
            \item[利用空间局部性] 块通常包含有多个数据对象。
        \end{description}
    }
}
