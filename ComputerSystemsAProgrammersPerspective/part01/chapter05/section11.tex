%%
%% Author: Clay
%% 2020/6/2
%%

\section{一些限制因素}
{
    关键路径指明了执行该程序所需时间的一个基本下界。
    功能单元的吞吐量界限也是程序执行时间的一个下界。

    \subsection{寄存器溢出}
    {
        循环并行性好的代码受汇编代码描述计算的能力限制。
        如果并行度 $p$ 超过了可用的寄存器数量，那么编译器会诉诸\emreg{溢出(spilling)}，将某些值临时放到内存中。

        一旦编译器必须要诉诸寄存器溢出，那么维护多个累积变量的优势就很可能消失。
    }

    \subsection{分支预测和预测错误处罚}
    {
        只要指令遵循的是一种简单的顺序，那么这种\emreg{指令流水线化(instruction pipelining)}就能很好地工作。
        当遇到分支的时候，处理器必须猜测分支该往哪个方向走。

        在一个使用\emreg{投机执行(speculative execution)}的处理器中，处理器会开始执行预测的分支目标处的指令。
        它会避免你修改任何实际的寄存器或内存位置，直到确定了实际的结果。
        如果预测正确，那么处理器就会提交结果。
        如果预测错误，处理器必须丢弃掉所有的结果，在正确的位置，重新开始取指令的过程。

        \subsubsection{不要过分关心可预测的分支}
        {
            现代处理器中的分支预测逻辑非常善于辨别不同的分支指令的有规律的模式和长期的趋势。
        }

        \subsubsection{书写适合用条件传送实现的代码}
        {
            对于本质上无法预测的情况，如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可以极大地提高程序的性能。

            %9.
            \begin{practicec}
                \begin{lstlisting}
long int dest1 = src1[i1++];
long int dest2 = src2[i2++];

int take1 = dest1 < dest2;

dest[id++] = take1 ? dest1 : dest2;
i1 -= (1 - take1);
i2 -= take1;
                \end{lstlisting}
            \end{practicec}
        }
    }
}
