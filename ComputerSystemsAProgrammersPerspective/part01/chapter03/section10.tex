%%
%% Author: Clay
%% 2020/4/30
%%

\section{在机器级程序中将控制与数据结合起来}
{
    \subsection{理解指针}
    {
        指针以一种统一方式，对不同数据结构中的元素产生引用。

        指针和它们映射到机器代码的关键原则：

        \begin{itemize}
            \item 每个指针都对应一个类型。
            \item 每个指针都有一个值。
            \item 指针用\emcode{\&{}}运算符创建。
            \item \emcode{*}操作符用于间接引用指针。
            \item 数组与指针紧密联系。
            \item 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变值。
            \item 指针也可以指向函数。
        \end{itemize}
    }

    \subsection{应用：使用GDB调试器}
    {
        GNU的调试器GDB提供了许多有用的特性，支持机器级程序的运行时评估和分析。
    }

    \subsection{内存越界引用和缓冲区溢出}
    {
        C对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。
        这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。

        一种特别常见的状态破坏称为\emreg{缓冲区溢出(buffer overflow)}。

        %46.
        \begin{practicec}
            \begin{enumerate}[A.]
                \item
                {
                    \[
                        00 00 00 00 00 40 00 76 \\
                        01 23 45 67 89 ab cd ef
                    \]
                }
                \item
                {
                    \[
                        00 00 00 00 00 40 00 34 \\
                        33 32 31 30 39 38 37 36 \\
                        35 34 33 32 31 30 39 38 \\
                        37 36 35 34 33 32 31 30
                    \]
                }
                \item $0x40 00 34$
                \item rbx
                \item 没有强制转型。计算大小错误。
            \end{enumerate}
        \end{practicec}

        缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。
        这是一种最常见的通过计算机网络攻击系统安全的方法。
        通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为\emreg{攻击代码(exploit code)}，另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。
        那么，执行ret指令的效果就是跳转到攻击代码。

        在一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给供给者提供一组操作系统函数。
        在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret命令，（表面上）正常返回到调用者。
    }

    \subsection{对抗缓冲区溢出攻击}
    {
        \subsubsection{栈随机化}
        {
            过去，程序的站地址非常容易预测。
            对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。
            因此，如果攻击者可以确定一个常见的Web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。
            许多系统都容易受到同一种病毒的攻击，这种现象常被称作\emreg{安全单一化(security monoculture)}。

            \emreg{栈随机化}的思想使得栈的位置在程序每次运行时都有变化。
            程序开始时，在栈上分配一段 $0 \sim n$ 字节之间的随机大小的空间。

            在Linux系统中，栈随机化已经变成标准行为。
            它是更大的已累计书中的一种，这类技术称为\emreg{地址空间布局随机化(Address-Space Layout Randomization)}。

            一个执着的攻击者总是能够用蛮力客服随机化，他可以反复地用不同的地址进行攻击。
            一种常见的把戏就是在实际的攻击代码前插入很长一段的nop指令。
            这个序列常用的术语是\emreg{空操作雪橇(nop sled)}。

            %47.
            \begin{practicec}
                \begin{enumerate}[A.]
                    \item 8192
                    \item 64
                \end{enumerate}
            \end{practicec}
        }

        \subsubsection{栈破坏检测}
        {
            计算机的第二道防线是能够检测到何时栈已经被破坏。
            破坏通常发生在当超越局部缓冲区的边界时。

            最近的GCC版本在产生的代码中加入了一种\emreg{栈保护者(stack protector)}机制，来检测缓冲区越界。
            其思想是在栈帧中任何局部缓冲区于栈状态之间存储一个特殊的\emreg{金丝雀(canary)}值。
            也成为\emreg{哨兵值(guard value)}，是在程序每次运行时随机产生的。
            在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的操作改变了。
            如果是的，那么程序异常中止。

            金丝雀值是用\emreg{段寻址(segmented addressing)}从内存中读入的。
            将金丝雀值放在一个特殊的段中，标志位只读，这样攻击者就不能覆盖存储的金丝雀值。
            在恢复寄存器状态和返回之前，函数将存储在栈位置处的值与金丝雀值作比较。

            栈保护很好的防止了缓冲区溢出攻击破坏存储在程序栈上的状态。
            它只会带来很小的性能损失。

            %48.
            \begin{practicec}
                \begin{enumerate}[A.]
                    \item
                    {
                        24\%rsp, (\%rsp), 无；
                        8(\%rsp), 16(\%rsp), 40(\%rsp)
                    }
                    \item
                    {
                        交换v和buf。
                    }
                \end{enumerate}
            \end{practicec}
        }

        \subsubsection{限制可执行代码区域}
        {
            最后一招是消除攻击者像系统中可执行代码的能力。
            一种方法是限制哪些内存区域能够存放可执行代码。
            在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。
            其它的部分被限制为只允许读和写。
        }
    }

    \subsection{支持变长栈帧}
    {
        有些函数需要的局部存储是变长的。

        %49.
        \begin{practicec}
            \begin{enumerate}[A.]
                \item
                {
                    \%rax = 22 + 8 * n;
                    \%rax &= -16;
                    \%rsp -= \%rax;
                }
                \item
                {
                    \%rax = \%rsp + 7
                    \%rax >= 3
                    \%r8 = 8 * \%rax
                }
                \item
                {
                    \begin{table}[htb]
                        \begin{tabular}{|cccccc|}
                            \hline
                            n & s_1 & s_2 & p & e_1 & e_2 \\
                            \hline
                            5 & 2065 & 2017 & 2024 & 1 & 7 \\
                            6 & 2064 & 2000 & 2000 & 16 & 0 \\
                            \hline
                        \end{tabular}
                    \end{table}
                }
                \item
                {
                    $s_2$ 与 $s_1$ 以16对齐， $p$ 与
                }
            \end{enumerate}
        \end{practicec}
    }
}
