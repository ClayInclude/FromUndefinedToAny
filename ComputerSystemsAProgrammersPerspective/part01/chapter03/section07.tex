%%
%% Author: Clay
%% 2020/4/25
%%

\section{过程}
{
    过程是软件中一种很重要的抽象。
    它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。
    设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义。
    不同的编程语言中，过程的形式多样：\emreg{函数(function)、方法(method)、子例程(subroutine)、处理函数(handler)}等等。

    假设过程P调用过程Q，Q执行后返回到P。
    这些动作包括下面一个或多个机制：

    \begin{description}
        \item[传递控制] 在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。
        \item[传递数据] P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。
        \item[分配和释放内存] 在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。
    \end{description}

    \subsection{运行时栈}
    {
        当Q在执行时，P以及所有向上追溯到P的调用链中的过程，都是暂时被挂起的。
        当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。
        当Q返回时，任何他所分配的局部存储空间都可以被释放。
        因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。
        当P调用Q时，控制和数据信息添加到栈尾，当P返回时，这些信息会释放掉。

        当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。
        这个部分的称为过程的\emreg{栈帧(stack fram)}。

        许多函数根本不需要栈帧。
    }

    \subsection{转移控制}
    {
        将控制从函数P转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位置。
        当从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。

        指令\emcode{call}会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在\emcode{call}指令后面的那条指令的地址。
        对应的指令\emcode{ret}会从栈中弹出地址A，并把PC设置为A。

        %32.
        \begin{practicec}

        \end{practicec}
    }

    \subsection{数据传送}
    {
        过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。
        x86--64中可以通过寄存器最多传递6个整形参数：
        \emcode{\%rdi, \%rsi, \%rdx, \%rcx, \%r8, \%r9}。

        如果一个函数有大于6个整型参数，超出的6个部分就要通过栈来传递。

        %33.
        \begin{practicec}
            (unsigned) int a, char b, long int *u, char *v
        \end{practicec}
    }

    \subsection{栈上的局部存储}
    {
        有些时候，局部数据必须存放在内存中，常见的情况包括：

        \begin{itemize}
            \item 寄存器不足够存放所有的本地数据。
            \item 对一个局部变量使用地址运算符，因此必须能够为它产生一个地址。
            \item 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。
        \end{itemize}
    }

    \subsection{寄存器中的局部存储空间}
    {
        寄存器组是唯一被所有过程共享的资源。
        虽然在给定时刻只有一个过程是活动的，仍然必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。

        根据惯例，寄存器\emcode{\%rbx, \%rbp, \%r12 \~{} \%r15}被划分为\emreg{被调用者保存}寄存器。
        当过程P调用Q时，Q必须保证它们的值在Q返回到P时与Q被调用时是一样的。
        要么是根本不去改变它，要么是把原始值压入栈中，然后再返回前从栈中弹出旧值。

        所有其他的寄存器，除了栈指针\emcode{\%rsp}都分类为\emreg{调用者保存}寄存器。
        这就意味着任何函数都能修改它们。

        恢复寄存器值的时候，弹出顺序与压入顺序相反。

        %34.
        \begin{practicec}
            \begin{enumerate}[A.]
                \item a0 \~{} a5
                \item a6, a7
                \item 被调用者寄存器只有6个。
            \end{enumerate}
        \end{practicec}
    }

    \subsection{递归过程}
    {
        递归调用一个函数本身与调用其他函数是一样的。
        栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息。
        如果需要，它还可以提供局部变量的存储。
        栈分配和释放的规则很自然地就与函数调用-返回的顺序匹配。

        %35.
        \begin{practicec}
            \begin{lstlisting}[language=C]
long int rfun(unsigned long int x)
{
    if (!x)
    {
        return 0;
    }

    unsigned long int nx = x >> 2;
    long rv = rfun(nx);

    return x + rv;
}
            \end{lstlisting}
        \end{practicec}
    }
}
