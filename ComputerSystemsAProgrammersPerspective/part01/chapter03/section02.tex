%%
%% Author: Clay
%% 2020/3/20
%%

\section{程序编码}
{
    使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。

    C\emreg{预处理器}扩展源代码，插入所有用\emcode{\#include}命令指定的文件，并扩展所有用\emcode{\#define}声明指定的宏。
    其次，\emreg{编译器}产生源文件的汇编代码。
    接下来，\emreg{汇编器}会将汇编代码转化成二进制\emreg{目标代码}文件。
    目标代码是机器代码的一种形式，但是还没有填入全局值的地址。
    最后，\emreg{链接器}将目标代码文件与实现库函数的代码合并，并生成最终的可执行代码文件。

    \subsection{机器级代码}
    {
        计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。
        第一种是由\emreg{指令集体系结构或指令集架构(Instruction Set Architecture, ISA)}来定义机器级程序的格式和行为。
        它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
        第二种抽象是，机器级程序使用的内存是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

        x86--64的机器代码和原始的C代码差别非常大。
        一些通常对C语言程序员隐藏的处理器状态都是可见的：

        \begin{itemize}
            \item \emspe{程序计数器}（通常称为PC，在x86--64中用\emcode{\%rip}表示）给出将要执行的下一条指令在内存中的地址。
            \item 整数\emspe{寄存器文件}包含16个命名的位置，分别存储64位的值。
            \item 这些寄存器可以存储地址或整数数据。
            \item 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。
            \item 一组向量寄存器可以存放一个或多个整数或浮点数值。
        \end{itemize}

        机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。
        C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。
        即使对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。

        程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。
        程序内存用虚拟地址来寻址。
        在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。
        操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
    }

    \subsection{代码示例}
    {
        机器执行的程序只是一个字节序列，它是一些列指令的编码。
        机器对产生这些指令的源码几乎一无所知。

        \emreg{反汇编器(disassembler)}根据机器代码产生一种类似于汇编代码的格式。

        一些关于机器代码和它的反汇编表示的特性值得注意：

        \begin{itemize}
            \item x86--64的指令长度从1到15个字节不等，常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
            \item 设计指令格式的方式是，从某个位置开始，可以将字节唯一地解码成机器指令。
            \item 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。
        \end{itemize}

        生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个\emcode{main}函数。

        链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。
    }

    \subsection{关于格式的注解}
    {
        所有以\emcode{.}开头的行都是指导汇编器和链接器工作的伪指令。

        对于一些应用程序，程序员必须用汇编代码来访问机器的低级特性。
        一种方法是用汇编代码编写整个函数，在连接阶段把它们和C函数组合起来。
        另一种方法是利用GCC的支持，直接在C程序中嵌入汇编代码。
    }
}
