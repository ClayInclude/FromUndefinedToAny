%%
%% Author: Clay
%% 2020/9/14
%%

\section{操作系统的发展}
{
    \subsection{串行处理}
    {
        早期的计算机，因没有操作系统，程序员直接与计算机硬件交互。
        这些计算机运行在一个控制台上，控制台包括显示灯、切换开关、某种形式的输入设备和打印机。
        用机器代码编写的程序通过输入设备加载到计算机。
        如果某个错误停止了程序的运行，显示灯会指示错误原因。
        如果程序正常执行完，则通过打印机输出结果。

        这些早期的系统存在两个主要问题：

        \begin{description}
            \item[调度]
            {
                大多数装置使用硬拷贝登记表来申请计算机时间。
                通常，用户可以申请半小时的整数倍的时间。
                剩下的时间计算机就只能闲置，从而造成浪费。
                另一方面，用户可能会遇到问题，而不能在分配的时间内顺利完成，在解决这个问题之前就被迫终止运行。
            }
            \item[启动时间]
            {
                单个程序，也被称为\emreg{作业(Job)}，有很多步骤。
                将编译器和用高级语言编写的源程序加载到内存，保存编译好的目标程序，然后加载目标程序和公用函数并链接在一起。
                其中每一步都可能需要安装/拆卸磁带，或者设置卡片组。
                如果此期间产生了错误，用户通常不得不回到起点重新开始。
            }
        \end{description}

        这种操作模式称为\emreg{串行处理(Serial Processing)}，表示用户需要顺序地访问计算机。
    }

    \subsection{简单批处理系统}
    {
        为了提高处理器利用率，批处理操作系统应运而生。

        简单批处理方案的核心思路是使用一个称为\emreg{监控(Monitor)}程序的软件。
        在这种操作系统中，用户不在直接访问处理器。
        相反，用户将卡片或磁带上的作业提交给计算机操作员，该操作员负责将所有的作业按顺序组织成一批，然后将整批作业放到输入设备上，供监控程序使用。
        每个程序在处理完成之后都会返回给监控程序。
        然后监控程序自动加载下一个程序。

        \begin{description}
            \item[从监控程序角度来看]
            {
                监控程序控制事件的执行顺序。
                大部分监控程序必须常驻内存且可以执行，称为\emreg{常驻监控程序(Resident Monitor)}。
                监控程序中的其他部分包括实用程序和公用函数，作为用户程序的子程序，在作业开始执行时被载入。
                监控程序每次从输入设备读入一个作业，放到用户程序区域，并将控制权转交给该作业。
                作业完成后，则将控制权返回给监控程序，监控程序立刻读取下一个作业。
                每个作业的结果会传送给输出设备，交付给用户。
            }
            \item[从处理器角度来看]
            {
                从某个角度来看，处理器执行内存中存放的监控程序的指令，将下一个作业读入内存并存放到内存的其他区域。
                一旦作业被载入，处理器将会遇到监控程序中的分支指令，该分支指令引导处理器从用户程序的起点继续执行。
                处理器会继而执行用户程序中的指令。
                直至遇到结束指令或错误条件。
                不论何种情况都会让处理器从监控程序中读取下一条指令。
            }
        \end{description}

        监控程序负责调度功能：一批作业排队等候，处理器尽可能迅速地调度作业执行。
        监控程序还缩短了作业的启动时间。
        监控程序或批处理操作系统，都只是一个简单的计算机程序。
        它依赖于处理器从内存的不同区域读取指令的能力，以交替地获取或释放控制权。
        此外，其他的一些硬件特性也需要考虑。

        \begin{description}
            \item[内存保护]
            {
                在用户程序的执行过程中，不能修改内存中的监控程序。
            }
            \item[计时器]
            {
                计时器用于防止作业独占系统。
            }
            \item[特权指令]
            {
                某些机器指令被设计成特权指令，只能由监控程序执行。
                I/O指令属于特权指令，因此监控程序可以控制所有I/O设备。
            }
            \item[中断]
            {
                这一特性使操作系统让用户程序释放控制权或从用户程序获取控制权时具有更大的灵活性。
            }
        \end{description}

        内存保护合特权指令引入了操作模式的概念。
        用户程序再\emreg{用户态(User Mode)}下执行，在此模式下某些内存区域被保护而不能被用户使用，某些指令也不能被用户执行。
        监控程序在系统态下执行，有时也称为\emreg{内核态(Kernel Mode)}，此时可以执行特权指令，受保护的内存区域也可以访问。

        在批处理操作系统中，用户程序和监控程序在处理器上交替执行。
        这造成了两个方面的损失：
        一部分内存分配给了监控程序；
        监控程序消耗了一部分处理器时间。
    }

    \subsection{多道批处理系统}
    {
        简单批处理操作系统提供了作业自动排队的功能，但处理器仍存在空闲等待现象，其原因是I/O设备的速度比处理器要慢。

        这种低效率的情况是可以避免的。
        系统需要有足够的内存空间存放操作系统和用户程序。
        当一个作业需要等待I/O时，处理器可以转去处理另一个可能不需要等待的I/O作业。
        该方法称为\emreg{多道程序设计(Multiprogramming)}或\emreg{多任务处理(Multitasking)}，它是现代操作系统的主要方案。

        与简单批处理系统一样，多道批处理系统必须依赖于计算机的某些硬件特征。
        对多道程序设计有用的、最想住的辅助特征是支持I/O中断和直接存储器访问(DMA)的硬件。

        对准备运行多个作业，必须将它们载入内存，这就需要\emreg{内存管理(Memory Management)}。
        此外，如果多个作业准备运行，处理器必须选定一个作业运行，这就需要调度算法来决定。
    }

    \subsection{分时系统}
    {
        对于许多作业来说，需要提供一种模式，让用户可以直接与计算机交互。

        多道程序设计可用于处理多个交互作业。
        在这种情况下，多个用户分享处理器时间，因此该技术称为\emreg{分时(Time Sharing)}技术。
        在分时系统中，多个用户通过终端同时访问系统，操作系统控制每个用户程序以很短的时间为单位交替执行。

        CTSS系统时钟大约每隔0.2秒产生一次中断，在每次时钟中断到来时，操作系统恢复控制权，将处理器分配给另一个用户。
        这项技术称为\emreg{时间片(Time Slicing)}技术，在固定的时间间隔内，当前用户被抢占，另一个用户被载入。
        为了保护原有用户程序的状态以便恢复，在新用户程序和数据读入之前，会将原有的用户程序与数据写出到磁盘。
        随后，当程序再次获得控制权时，原来的用户程序代码和数据会被恢复到内存。

        为了减少磁盘数据传输，只有在新程序要重写用户内存空间时，才将该内存空间中的数据写出到磁盘。

        如果内存中有多个作业，系统必须提供保护机制以免相互干扰。
        对多个交互用户，需要对文件系统进行保护，还需要解决资源竞争的问题。
    }
}
