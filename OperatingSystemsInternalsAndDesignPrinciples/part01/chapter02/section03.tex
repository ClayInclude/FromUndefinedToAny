%%
%% Author: Clay
%% 2020/9/14
%%

\section{主要成就}
{
    \subsection{进程}
    {
        \emreg{进程(Process)}的概念是操作系统设计的核心。
        有很多关于进程这个术语的定义：

        \begin{itemize}
            \item 一个正在执行的程序。
            \item 程序在计算机上运行的一个实例。
            \item 可以分配给处理器，并由处理器执行的一个实体。
            \item 由一个顺序执行的线程、一个当前状态和一组相关的系统资源所构成的活动单元。
        \end{itemize}

        计算机系统发展的第一条主线是多道程序设计技术让处理器和I/O设备同时处于忙碌状态，以达到最大效率。
        它的关键机制是：
        为响应表示I/O事务完成的信号，操作系统对驻留在内存中的各种程序进行处理器切换。

        计算机系统发展的第二条主线是通用目的的分时，其主要目标是能及时响应单个用户的请求。
        在计算中还必须考虑操作系统的开销因素。

        计算机系统发展的第三条主线是实时事务处理系统。
        这种情况下，大量用都需要查询或修改数据库。
        事务处理系统和分时系统的主要区别在于前者局限于一个或几个应用，而分时系统的用户可以编写程序、执行作业和使用各种应用程序。
        对这两种情况，系统响应时间都是最重要的。

        系统程序员在开发早期的多道程序设计和多用户交互系统时使用的主要工具是中断。
        任何一个作业的活动都可能因某个已定义的事件而暂停执行。
        处理器会保存某些上下文，然后跳转到中断处理程序，确定中断类型并处理该中断，然后恢复用户被中断的作业或其他作业的处理。

        产生错误的原因主要有4个：

        \begin{description}
            \item[不正确的同步]
            {
                程序在执行时经常需要暂停等待系统中其他地方的某个事件。
                这种情况下，需要来自其他例程的信号，而如果信号机制设计的不正确，将会造成信号丢失或接收到重复信号。
            }
            \item[失败的互斥]
            {
                多个用户或程序往往需要同时使用一个共享资源。
                需要提供信号灯互斥机制，以保证一次只能有一个程序对该文档执行修改操作。
                对所有可能的时间序列逐一验证是很困难的，说明实现的这种互斥机制都是正确的。
            }
            \item[不确定的程序操作]
            {
                当多个程序共享内存、并在处理器上交替执行时，这些程序可能以无法预测的方式重写相同内存区域的内容而互相影响。
                程序调度顺序可能会影响某个特定的程序的输出结果。
            }
            \item[死锁]
            {
                很可能有两个或多个程序因互相等待而被挂起。
                每个程序都等待对方释放自己所需的资源。
                这样的死锁依赖于资源分配和释放的时机。
            }
        \end{description}

        解决这些问题需要一种系统级的方法，来监控和控制处理器上各种程序的执行。
        进程这一概念为此提供了基础，进程可视为由3部分组成：

        \begin{itemize}
            \item 一个可执行的程序
            \item 程序所需的相关数据
            \item 程序执行的上下文
        \end{itemize}

        最后一部分必不可少。
        \emreg{执行上下文(Execution Context)}，也称\emreg{进程状态(Process State)}，是操作系统管理和控制进程的内部数据。
        该内部信息与进程是分开的，因为操作系统不允许被进程直接访问。
        上下文包括操作系统管理进程和处理器正确执行进程所需要的所有信息，包括各种处理器寄存器的内容，还包括操作系统使用的信息，如进程优先级、进程是否等待特定I/O事件的完成等。

        每个进程都拥有一块内存空间，用于存放进程对应的程序、数据和上下文信息。
        每个进程信息都记录在由操作系统创建和维护的进程表中。
        进程表记录每个进程的入口，包括指向存放该进程的内存空间的地址指针，还包括该进程的部分或全部执行上下文。

        进程被当作数据结构来实现。
        一个进程可以正在执行，也可以处于等待执行状态。
        任何时候进程的整个状态信息都包含在它的上下文中。
        该结构允许利用超强技术来确保进程间的协作和合作。
        还可以通过扩展上下文、增加支持新特性的信息来设计一些新特性，并融入操作系统中。

        一个分配了资源的进程可以分解为多个并发的\emreg{线程(Thread)}，这些线程相互协作完成进程的工作。
        此时，产生了一个新的并行活动的层次，需要由硬件和软件共同管理。
    }

    \subsection{内存管理}
    {
        操作系统承担了内存管理的以下5项基本职责：

        \begin{description}
            \item[进程隔离] 操作系统必须实现进程保护，防止独立的进程相互干扰和访问对方的内存空间，包括数据和指令。
            \item[自动分配和管理] 程序应能根据存储层次的需求动态分配内存，而且该分配应对程序员透明。
            \item[支持模块化编程] 程序员应能定义程序模块，动态创建和销毁这些模块，动态调整这些模块的大小。
            \item[保护和访问控制]
            {
                无论在存储层次的哪一层，存储器的共享都会产生一个程序访问另一个程序存储空间的可能。
                而当某个特定的应用程序需要共享时，这种情况是可取的。
                但在其他时候，他将对程序的完整性造成威胁，甚至对操作系统也会造成威胁。
                操作系统必须允许各种用户以各种方式访问内存的一部分。
            }
            \item[永久存储] 许多应用程序需要在计算机关机后仍能长时间保存信息。
        \end{description}

        通常操作系统利用虚拟内存和文件系统机制满足这些需求。
        文件系统将信息保存在称为文件的有名对象中实现永久存储。
        对程序员来说，文件是一个方便的概念；
        对操作系统来说，文件是一个能有效进行访问控制和保护的单元。

        虚拟内存允许程序从逻辑的角度访问内存，而无需考虑有效物理内存的容量。
        虚拟内存的构想是为了满足多个用户作业同时驻留在内存的需求，这样，当一个进程被写出到辅存时，后续进程能无缝地读入内存并执行。
        由于进程大小不同，当处理器需要在很多进程间切换时，很难把它们紧密地压入内存，因此，产生了分页系统。
        在分页系统中，进程由许多大小相等的块组成，这些块称为页。
        程序通过\emreg{虚拟地址(Virtual Address)}访问字，虚地址由页号和页内位移组成。进程的每一页可能存放在内存的任何一个区域，分页系统提供程序中的虚地址和内存中的\emreg{实际地址(Real Address)}或物理地址间的动态映射。

        有了动态地址映射的硬件支持，下一步就是解决进程的所有页同时驻留内存的问题。
        进程的所有页面都存放在磁盘上，在进程执行时，部分页面被读入内存。
        如果访问的页面不在内存，内存管理的硬件会检测到该问题，并将缺失的页面读入内存，这个机制称为\emreg{虚拟内存(Virtual Memory)}。

        处理器硬件和操作系统一起为用户提供能访问虚拟内存的虚拟处理器。
        该内存可以是一个线性地址空间，也可以是一系列段的集合。
        无论何种情况，程序指令都能访问位于虚拟内存中的程序和数据。
        可以给每个进程分配一个唯一且不重叠的虚拟内存空间来实现进程隔离，重叠两个虚拟内存的一部分就可以实现内存共享。
        文件可用于永久存储，文件和文件的部分内容可以复制到虚拟内存供程序使用。

        存储器由内存和慢速的辅存组成，机器指令能直接访问内存，但不能直接访问辅存，需要将辅存中的块加载到内存后才能访问。
        地址转换硬件（内存管理单元）位于处理器和内存之间。
        程序的访问使用虚地址，虚地址会被映射为内存地址。
        如果访问的虚地址不在内存，内存中的一部分数据将被换出到辅存，然后换入所需的数据块。
        而在此过程中对该地址访问的进程将被阻塞执行。
        因此，操作系统设计者在开发时应尽可能地减少地址转换机制的开销，设计合理的存储分配策略已尽可能减少各级存储器间的传输。
    }

    \subsection{信息保护和安全}
    {
        信息保护是在分时系统的使用过程中提出来的。
        需要关注的是计算机系统及其存储在系统中的信息的访问控制问题。

        与操作系统密切相关的安全保护问题主要分为以下4类：

        \begin{description}
            \item[可用性] 保护系统不被中断运行
            \item[保密性] 确保用户不能访问未授权的数据
            \item[数据完整性] 保护数据免遭未授权的修改
            \item[可靠性] 用户身份验证和消息/数据的有效性保障
        \end{description}
    }

    \subsection{调度和资源管理}
    {
        操作系统的一个关键任务是管理各种可用资源，并调度各种活动进程使用这些资源。
        任何一个资源分配和调度策略都必须考虑以下3个因素：

        \begin{description}
            \item[公平性] 通常，所有参与竞争某一特定资源的进程能几乎相等且公平地访问资源。
            \item[有差别的响应性]
            {
                另一方面，操作系统需要区分有不同服务需求的不同类别的作业。
                操作系统将试图采用满足所有需求的资源分配方案和调度策略，并动态执行。
            }
            \item[有效性] 操作系统希望最大化吞吐量和最小化响应时间，并在分时情况下，尽可能容纳更多的用户。
        \end{description}

        调度和资源管理本质上是运筹学问题。

        操作系统维护多个队列，每个队列为等待某个资源的进程列表。
        短期队列由在内存（或至少一部分在内存）中并等待使用处理器（只要处理器空闲就能马上运行）的进程组成。
        常用的策略是依次为每个进程分配一定的时间，称为轮询调度策略，利用环形队列实现时间片轮转。
        另一个策略是为不同的进程分配不同的优先级，调度器根据优先级的高低进行调度。

        长期队列是等待使用处理器的新作业的列表。
        操作系统通过将作业从长期队列移至短期队列来实现向系统中添加作业，这时需要为新到来的进程分配内存空间。

        如果产生了中断，操作系统将在中断处理程序的入口得到处理器的控制权。
        进程可以通过服务调用的方式明确请求使用操作系统的某个服务。
    }
}
