%%
%% Author: Clay
%% 2020/12/7
%%

\section{死锁避免(Deadlock Avoidance)}
{
    死锁预防的方法实际上是在满足资源请求的方式上做出某种限制，使其破除死锁发生的某一个条件，从而使得死锁不可能发生。
    这些方法往往会导致资源利用率的下降，或进程执行速度的降低。
    死锁避免与之前讨论的死锁预防有细微的差别，该方案允许死锁发生的前3个必要条件存在，但在资源分配的时候做出谨慎的决策，以避免死锁的发生。

    \subsection{拒绝创建进程}
    {
        考虑一个有着n个处理器和m种不同类型资源的系统。

        资源向量：系统中全部的资源。

        \begin{align*}
            R = (R_1, R_2, ..., R_m)
        \end{align*}

        可用资源向量：系统中的剩余可用资源。

        \begin{align*}
            V = (V_1, V_2, ..., V_m)
        \end{align*}

        资源申请矩阵： $C_{ij}$  进程i申请资源j的总数量。

        \begin{align*}
            C =
            \begin{pmatrix}
                C_{11} & C_{12} & \cdots & C_{1m} \\
                C_{21} & C_{22} & \cdots & C_{2m} \\
                \vdots & \vdots & \ddots & \vdots \\
                C_{n1} & C_{n2} & \cdots & C_{3m} \\
            \end{pmatrix}
        \end{align*}

        资源分配矩阵： $A_{ij}$ 进程i获得资源j的数量。

        \begin{align*}
            A =
            \begin{pmatrix}
                A_{11} & A_{12} & \cdots & A_{1m} \\
                A_{21} & A_{22} & \cdots & A_{2m} \\
                \vdots & \vdots & \ddots & \vdots \\
                A_{n1} & A_{n2} & \cdots & A_{3m} \\
            \end{pmatrix}
        \end{align*}

        有以下公式成立：

        \begin{itemize}
            \item 对于所有的 $j$ ，有 $R_j \geq V_j + \sum_{i = 1}^N A_{ij}$ ，所有的资源要么可用要么已经被分配。
            \item 对于所有的 $i$ 和 $j$ ，有 $\sum_{i = 1}^N C_{ij} \leq R{j}$ ，申请的资源个数小于等于系统的总资源个数。
            \item 对于所有的 $i$ 和 $j$ ，有 $A_{ij} \leq C_{ij}$ ，获得的资源个数小于等于申请的资源个数。
        \end{itemize}

        死锁避免方案可以要求在创建一个新进程P(n + 1) 时有：

        对于所有的 $j$ ，有 $R_j \geq C_{n + 1}j + \sum_{i = 1}^N C_{ij}$ 。

        仅当所创建的进程对各类资源需求量加上系统中已有进程对各类资源的申请量的和，小于系统中所有各类资源的总量时，该进程才被允许创建。
        很显然，这个策略并不是最有效的，因为它假设的是最坏情况：
        所有进程都同时申请最大数量的资源。
    }

    \subsection{拒绝分配资源}
    {
        拒绝资源分配的策略又被称为\emreg{银行家算法(Banker's Algorithm)}，由Dijkstra提出。

        考虑一个有固定数量的进程和固定数量资源的系统，进程可在任意时刻发出资源请求。
        系统的\emreg{状态(State)}就反映了系统当前的资源分配情况。
        \emreg{安全状态(Safe State)}的定义是：至少存在一个资源分配序列，使得系统不会出现死锁现象。
        与之相反，\emreg{不安全状态(Unsafe State)}就是指找不到这样的一个资源分配序列的情况。

        满足以下不等式：

        \begin{align*}
            C_{ij} - A_{ij} \leq V_j
        \end{align*}

        采用银行家算法避免死锁的核心思想就是：
        保证系统一直处于安全状态。
        具体做法是：
        当收到一个进程发出的资源申请后，假设允许该请求，并相应更新系统状态和判断更新后的结果状态是否仍然安全。
        如果安全，则允许该请求，否则，就阻塞申请进程直到系统认为它的申请安全后再继续它的执行。

        死锁避免方案并不能确切地预测死锁的发生，而只是通过判断避免一切发生死锁的可能。

        死锁避免方案的优点在于：
        相比于死锁检测，它的使用不需要抢占资源或回滚进程；
        相比于死锁预防，它更灵活。
        然而，该方案的缺点在于：

        \begin{itemize}
            \item 需要预先知道每个进程的最大资源需求量
            \item 进程本身必须是独立的
            \item 可分配资源的个数必须是固定的
            \item 进程结束时必须释放所有资源
        \end{itemize}
    }
}
