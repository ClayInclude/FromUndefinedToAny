%%
%% Author: Clay
%% 2020/12/7
%%

\section{死锁检测(Deadlock Detection)}
{
    死锁预防方案相对保守：
    它通过限制进程资源请求的方法，排除系统中出现死锁的可能。
    而死锁检测方案走的是另一个极端：只要系统有剩余的资源，所有对资源请求都将被允许。
    同时，操作系统周期性地调用死锁检测算法来检测系统中是否出现了等待环路。

    \subsection{死锁检测算法}
    {
        算法通过标记进程为非死锁进程来进行，初始情况下所有进程都未标记，算法的步骤如下：

        \begin{enumerate}
            \item 将资源分配矩阵A中全0的行所对应的进程打上标记。
            \item 初始化一个初值为可用资源向量的临时向量W。
            \item 在资源请求矩阵Q中找到未被标记的行i，使得对于 $1 \leq k \leq m$ 而言有 $Q_{ik} \leq W_k$ 。
            \item 如果找到满足条件的行，就将进程i打上标记，并将它对应的资源分配矩阵中的行加到W中。
        \end{enumerate}

        如果算法执行完后，还有未标记的进程，那么这些未标记的进程就是发生死锁的进程。
        该算法的核心思想是找到当前系统剩余资源的数量能够满足其需求的进程，并假设系统将剩余资源都分配给该进程，而得到资源的进程就能够执行完毕并最终释放其所占用的资源。
    }

    \subsection{死锁恢复}
    {
        一旦死锁被检测到，就需要进行恢复。

        \begin{enumerate}
            \item 终止所有死锁发生的进程。
            \item
            {
                将发生死锁的进程回退到最近的\emspe{检查点(Checkpoint)}，并重启所有进程。
                该方法需要操作系统内置\emreg{回滚(Rollback)}和\emreg{重启动(Restart)}机制。
                同时，该方法的危险在于系统可能再次进入之前的死锁状态。
            }
            \item 依次终止发生死锁的进程，直到死锁不再被检测到为止。
            \item 一次剥夺进程的资源，直到死锁不再被检测到为止。
        \end{enumerate}
    }
}
