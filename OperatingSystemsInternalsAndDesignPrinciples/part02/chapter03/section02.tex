%%
%% Author: Clay
%% 2020/11/16
%%

\section{进程状态}
{
    对每一个应用程序的执行，系统都会为其创建一个进程与之对应。
    从处理器的角度来看，它只是从程序计数器指向的地址中取得指令并执行。
    而程序计数器在系统运行过程中，可能时不时地从指向一个进程的代码转到指向另一个进程的代码，从而实现进程切换。
    而从单个的应用程序来看，它的执行对应的是它的代码所规定的一连串指令。

    现在将单个进程的行为抽象为一串指令，并称它为该进程的\emreg{执行轨迹(Trace)}。
    有了这个定义，就能够通过进程的执行轨迹来描述处理器的行为。

    \emreg{调度器(Dispatcher)}在内存的低端，用于调度进程的执行。

    \subsection{双状态模型}
    {
        操作系统的首要任务是控制进程的执行过程，这意味着它必须确定多个进程如何交替执行，以及如何为进程分配资源。
        为了达到这一目标，必须对进程的行为加以描述。
        先建立一个简单的模型，在任意时刻，进程只可能处于两种状态：
        要么执行，要么不执行。

        当操作系统创建一个新的进程时，创建该进程对应的进程控制块，并将该进程投入不执行态。
        之后，如果当前正在运行的进程用完了分配给它的时间片，它将被中断并进入不执行态，而调度程序将调入一个处于不执行态的进程投入运行。

        首先，每个进程必须能够被操作系统跟踪。
        一个进程必须包含一些必要的信息使得操作系统能够感知它的存在，并控制它的执行。
        其次，系统必须设计某种队列结构，来存放被暂停执行或暂时无法执行的进程的信息。

        通过双状态模型，可以描述调度器的行为：
        当前运行的进程要么因为用完时间片而被中断执行，并加入队列中等待，要么因为执行完毕而离开系统。
        无论哪一种情况发生，调度器都将从队列中取出一个进程，并将其投入运行。
    }

    \subsection{进程的创建和结束}
    {
        先讨论进程的\emreg{创建(Create)}和\emreg{结束(Termination)}，因为它们标志着一个进程的开始和结束。

        \subsubsection{进程的创建}
        {
            当创建一个进程的时候，操作系统将建立管理它的数据结构，并将其代码加载到内存空间。

            \begin{table}[htb]
                \centering

                \caption{创建进程的典型原因}

                \begin{tabular}{l|l}
                    \hline
                    新建一个批处理任务 & 在一个批处理作业流中，当操作系统完成了上一个作业，从作业流中读出下一个作业是 \\
                    \hline
                    交互式登录 & 用户通过一个交互式终端登录到某个系统中时 \\
                    \hline
                    操作系统创建，以提供某种服务 & 现代操作系统往往需要创建某种服务以辅助用户进程完成其工作 \\
                    \hline
                    被已存在的进程所创建 & 用户进程创建的一个子进程 \\
                    \hline
                \end{tabular}
            \end{table}

            一般来说，操作系统往往以对用户透明的方式来创建进程。
            然而，允许用户进程在执行过程中\emreg{显式(Explicit)}地通过调用系统调用创建进程，将对应用的构建非常有帮助。
            称这种通过显式系统调用创建一个新进程的方法称为\emreg{进程繁殖(Process Spawning)}。
            假如在运行过程中，进程A通过进程繁殖创建了进程B，就乘进程A为\emreg{父进程}，而进程B为\emreg{子进程}。
        }

        \subsubsection{进程结束}
        {
            \begin{table}[htb]
                \centering

                \caption{进程\emspe{结束(Termination)}}的典型原因

                \begin{tabular}{l|l}
                    \hline
                    正常结束(Completion) & 进程完成其工作任务，并调用系统调用完成撤销动作 \\
                    \hline
                    超时 & 进程的用时超过了用户定义的上限 \\
                    \hline
                    内存不足 & 进程需要的内存容量超出了系统所能够提供的上线 \\
                    \hline
                    访存超界 & 进程访问了超过其访问界限的内存空间 \\
                    \hline
                    保护错误 & 进程访问了某受保护的资源，或者使用了非法的访问方式访问该资源 \\
                    \hline
                    算术错误 & 进程在执行过程中执行了不被允许的算术指令 \\
                    \hline
                    等待时间过长 & 进程等待某事件发生的时间太长，超过了系统所规定的上限 \\
                    \hline
                    I/O失败 & 系统发生了I/O错误 \\
                    \hline
                    无效指令 & 执行了处理器所不能识别的指令 \\
                    \hline
                    特权态指令 & 用户态执行了只能在特权态下执行的指令 \\
                    \hline
                    数据错误 & 进程使用的数据类型不对，或者使用前未被合理地初始化 \\
                    \hline
                    操作员或操作系统介入 & 因为某种原因操作员或操作系统介入，强制杀死某进程 \\
                    \hline
                    父进程终止 & 当父进程终止的时候，某些极端情况下，操作系统会自动终止其所有子进程的执行 \\
                    \hline
                    父进程请求 & 父进程终止它的某个子进程 \\
                    \hline
                \end{tabular}
            \end{table}

            任何计算机系统都必须为进程提供某种方式，让它在结束执行时通知系统。
        }

        \subsubsection{五状态模型}
        {
            将不执行态加以区分，将其划分为两种状态：
            就绪态和阻塞态。
            这样，系统就存在5种状态：

            \begin{description}
                \item[运行态(Running)] 进程正在运行。
                \item[就绪态(Ready)] 进程已准备好执行，如果给它处理器，他就可以立即投入运行。
                \item[阻塞态/等待态(Blocked/Waiting)] 进程在等待某事件的发生。
                \item[新创建态(New)] 进程刚刚被创建，但还未被操作系统加入可执行队列。
                \item[结束态(Exit)] 进程结束，它所占用的系统资源被释放，但操作系统扔保留其控制结构。
            \end{description}

            进程状态可能发生的转换如下：

            \begin{description}
                \item[无 ---> 新创建态] 进程创建。
                \item[新创建态 ---> 就绪态] 当操作系统准备好一个新进程的执行时，它将挑选一个新创建态进程，将该进程的状态转到就绪态。
                \item[就绪态 ---> 运行态] 当处理器空闲时，操作系统从处于就绪态的进程中挑选一个进程，并将其投入运行。
                \item[运行态 ---> 结束态] 进程结束，或被操作系统撤销。
                \item[运行态 ---> 就绪态]
                {
                    导致这一状态改变的最常见的原因，是进程在执行过程中用完了分配给它的时间片。
                    对于这种情况，通常说操作系统\emreg{抢占(preempt)}了执行权。
                    最后，一个进程可能在运行过程中，\emreg{自愿(volumtarily)}放弃了自己的执行权。
                }
                \item[运行态 ---> 阻塞态] 进程在执行过程中，因为请求一些暂时得不到而必须等待的服务。
                \item[阻塞态 ---> 就绪态] 进程等待的事件到达后。
                \item[就绪态 ---> 结束态]
                \item[阻塞态 ---> 结束态]
            \end{description}

            为每一种可能到达的事件建立一个阻塞队列，将提高操作系统查找进程的速度。
            当某时间到达后，该事件对应的阻塞队列中所有的进程都将被转移到就绪态。

            如果操作系统系统采用了优先级调度策略，可以为每一个优先级组织一个就绪队列，也就是采用多就绪队列的方法。
            这样，操作系统能够较快速地找到高优先级的进程或等待时间最长的进程。
        }

        \subsubsection{进程挂起}
        {
            \paraph{交换(Swapping)的需要}
            {
                可能所有被载入内存的进程都进入了阻塞态，而处理器仍无事可做。

                一个解决方案是虚拟存储技术。
                这一技术可以将进程的一部分或者整个进程从内存交换到硬盘。
                当系统中没有进程处于就绪态时，操作系统就可以用虚拟存储技术，将其中一个处于阻塞态的进程交换到硬盘，将该进程的状态设置为\emreg{挂起状态(Suspend)}，并放到挂起状态对应的队列中。

                随着对虚拟存储技术的采用，引入了一个新状态：挂起状态。
                当系统中所有的进程进入阻塞态时，操作系统可以将其中一个阻塞态的进程转换为挂起状态，并将其内存镜像交换到硬盘中，从而腾出空间载入另一个进程。
                这时，系统面临两个选择：
                接受执行一个新创建的进程，或者调度执行一个之前处于挂起状态的进程。
                如果系统选择了后者，就会面临一个新的困难，那就是处于挂起状态的进程，在被换出之前都是处于阻塞态的。

                这里有两个互相独立的概念：
                进程是否在等待某个事件，以及进程是否从内存中被换出。
                显然，这是一个 $2 \times 2$ 的组合问题：

                \begin{description}
                    \item[就绪态(Ready)]
                    \item[阻塞态(Blocked)]
                    \item[阻塞且挂起态(Blocked-Suspend)]
                    \item[就绪且挂起态(Ready=Suspend)]
                \end{description}

                可能进行的状态转换：

                \begin{description}
                    \item[阻塞态 ---> 阻塞且挂起态] 如果系统中没有就绪态进程可调度，则其中至少一个阻塞态的进程将被交换到外存中。
                    \item[阻塞且挂起态 ---> 就绪且挂起态] 进程所等待的事件到达。
                    \item[就绪且挂起态 ---> 就绪态] 当系统中无就绪态进程时，操作系统将调入一个处于就绪且挂起态的进程到内存中。
                    \item[就绪态 ---> 就绪且挂起态]
                    {
                        一般情况下，操作系统更倾向于选择一个处于阻塞态的进程，将其换出到外存中。
                        然后，有时选择一个就绪态的进程将其换出到外村，可能时腾出大量连续内存空间的唯一方法。
                    }
                \end{description}

                还有一些值得讨论的状态转换：

                \begin{description}
                    \item[新创建态 ---> 就绪且挂起态及新创建态 ---> 就绪态]
                    {
                        当一个新创建的进程进入系统时，它要么被加入到就绪队列，要么被加入到就绪且挂起队列中。
                        将新创建的进程放到就绪且挂起状态是非常必要的，因为此时无需将它们完全载入内存。
                        同时，由于这种新创建进程的\emreg{用时调入机制(Just-In-Time)}，操作系统能够在自身非常繁忙的时候有效地处理大量新创建进程的任务。
                    }
                    \item{阻塞且挂起态 ---> 阻塞态}
                    {
                        看起来，这一状态转换对于一个实际运行的操作系统没有任何意义。
                        考虑以下情形：
                        当前执行的进程结束执行，并腾出了大量的内存空间。
                    }
                    \item{运行态 ---> 就绪且挂起态}
                    {
                        如果操作系统采用了抢占式调度方案，且有一个高优先级的进程从阻塞且挂起队列中被唤醒，从而抢占了当前运行进程的执行权，且此时因为该高优先级进程的换入导致了内存空间的紧张。
                        这种情况下，操作系统不得不中断正在运行的进程的执行，并将其换出到外存中，以腾出足够的内存空间。
                    }
                    \item{任意态 ---> 结束态}
                    {
                        一般情况下，只有处于运行态的进程会进入结束态。
                        其原因可能是它执行完了所有的预定任务，或者运行过程中发生了致命的错误。
                        然而，在有些操作系统因为某进程的终止，强制中止它所有的子进程。
                        这样，就意味着该系统中的进程可能从任意状态直接进入结束态。
                    }
                \end{description}
            }

            \paraph{挂起的其他用途}
            {
                挂起状态进程的概念:
                一个处于该状态的进程没有被调入到内存中，所以它无法被立即调度执行。

                处于该状态的进程的特点：

                \begin{enumerate}
                    \item 进程不能够被立即调入执行。
                    \item 进程可能在等待某事件的发生，如果这一条成立，阻塞态跟挂起态将同时存在且相互独立。
                    \item 进程必然是被另一个实体置为挂起状态的：可能时它的父进程、操作员或操作系统。
                    \item 一个处于挂起状态的进程必须等到将它挂起的实体发出明确的命令后，才能从挂起状态装换为其他状态。
                \end{enumerate}

                \begin{table}[htb]
                    \centering

                    \caption{进程挂起的原因}

                    \begin{tabular}{l|l}
                        \hline
                        交换 & 操作系统需要腾出内存空间，来调度执行另一个处于就绪态的进程 \\
                        \hline
                        其他的系统原因 & 操作系统可能会挂起一个背景进程或守护进程，也可能是一个普通用户进程以避免它可能导致的一些问题 \\
                        \hline
                        交互式系统中的用户请求 & 交互式系统中，用户可能需要挂起某进程以方便对其进行调试，或强制其暂时释放它所占据的资源 \\
                        \hline
                        时间因素 & 操作系统中有些进程，他们会被周期性唤醒，当未被唤醒时，就可能被置于挂起态 \\
                        \hline
                        父进程的请求 & 父进程在运行过程中可能会挂起它的一个子进程，以协调其它子进程的活动 \\
                        \hline
                    \end{tabular}
                \end{table}

                还有一些原因是由交互式终端的使用产生的。

                被挂起的进程的激活都需要最开始将其挂起的哪个实体明确的发出激活的命令。
            }
        }
    }
}
