%%
%% Author: Clay
%% 2020/12/2
%%

\section{并发的原理}
{
    在单处理器的\emreg{多道程序处理(Multiprogramming)}环境中，多个进程在时间上\emreg{穿插(Interleave)}执行，从而产生它们在一段时间内同时执行的假象。
    在拥有多处理器的计算机系统中，多道程序处理技术不仅能够实现多进程的执行在时间上的穿插，也能够执行在时间上的\emreg{重叠(Overlap)}。

    存在的并发问题的根源来自于多道程序处理系统的基本特征：
    进程相对执行速度的不可预测性。

    并发的存在问题主要有以下几个：

    \begin{itemize}
        \item 对全局资源的共享充满了危险。
        \item 操作系统很难对资源分配进行优化。
        \item 程序调试变得困难。
    \end{itemize}

    \subsection{一个简单例子}
    {
        让公共函数在多个应用间共享的方法，除了节约内存空间外，也使得应用间的有效交互成为可能。
        然而这种共享带来了新的问题。

        为了避免并发错误的产生，必须对共享变量进行保护，且保护的方法是控制来自多个进程的代码对该变量的访问。

        在单处理器环境中，并发问题的产生是因为中断的产生。
        在多处理器中，原因是多个进程同时执行，且同时访问了共享变量。
        解决并发问题的方法是相同的：
        控制对共享资源的访问。
    }

    \subsection{竞态(Race Condition)}
    {
        当系统中有多个进程不加控制地对公共变量进行读写，且该变量的最终结果取决于进程对它读写的顺序，就称该系统发生了竞态现象。
    }

    \subsection{操作系统的设计挑战}
    {
        并发的存在，对操作系统本身的设计带来了以下挑战。

        \begin{itemize}
            \item 操作系统必须能够跟踪进程的执行状态。
            \item 操作系统必须能够为进程分配和回收各种系统资源。
            \item 操作系统能够保护进程的数据和已拥有的物理资源，避免它们被其它进程非法访问。
            \item 进程的功能以及它的输出结果，必须与它跟系统中其它并发进程的相对速度无关。
        \end{itemize}
    }

    \subsection{进程交互}
    {
        根据进程了解对方的程度，将进程交互分为3类。

        \begin{description}
            \item[无交互]
            {
                这类进程一般是独立执行的。
                虽然这些进程不知道其他进程的存在，也不期望与其它进程在执行中通信，但他们都需要\emreg{竞争}使用系统资源。
                对于这类进程，操作系统需要协调他们对系统资源的使用。
            }
            \item[间接交互]
            {
                这类进程知道其他进程的存在，但不直接与其它进程开展通信。
                因为资源共享的存在，这类进程就必须在使用公共资源的时候与其它进程开展\emreg{协作}。
            }
            \item[直接交互]
            {
                这类进程知道对方的存在，且直接通过进程ID进行通信。
            }
        \end{description}

        \subsubsection{对资源的竞争使用}
        {
            当并发进程使用同一个资源时，往往导致并发问题。
            两个或两个以上的进程需要在它们的执行过程中访问同一个资源，每个进程都不知道对方的存在，同时也希望自己的执行不被其它进程打扰。
            最理想的状态是每个进程在使用完资源后，将该资源重置为被使用之前的状态。

            虽然以上的例子中进程间没有消息的交互，然而，一个进程的执行却有可能影响到参与资源竞争的其他进程的行为。
            当两个进程都希望访问同一个资源时，如果其中一个进程通过操作系统的到了该资源的访问权，则另一个进程就必须等待。
            所以，后者的执行速度实际上被拖慢了，在极端情况下，它可能永远都无法再次被调度执行。

            对于资源的竞争访问，导致了3个控制问题。
            第一个就是\emreg{互斥(Mutual Exclusion)}：
            假设两个或两个以上的进程需要访问一个不可共享的设备。
            在执行过程中，每个进程都会发送命令到该设备，以获得设备状态、发送或接收数据。
            通常称这类资源为\emreg{临界资源(Critical Resource)}，称进程中访问临界资源的代码为\emreg{临界区(Critical Section)}。
            显然，一次只能允许一个进程对临界资源进行访问。

            而互斥的使用，又可能导致两个额外的控制问题。
            一个是\emreg{死锁(Deadlock)}。
            每个进程在不释放自己已经获得的资源的前提下，同时又等待着获得另一个资源。
            这样，两个进程都无法向前推进，从而进入死锁状态。

            最后一个控制问题是\emreg{饥饿{Starvation}}。
            如果系统对资源访问的排队算法不恰当的话，虽然系统未发生死锁，但某个进程可能始终无法得到对资源的访问，从而无法向前推进。

            由于操作系统负责系统中资源的分配，如资源访问竞争的控制显然是操作系统的责任。
            另外，进程本身也需要采用某种机制（如锁），在获得该资源前，表达对资源的互斥访问。，这就需要操作系统本身提供了对这种机制的支持。
        }

        \subsubsection{通过共享的协作}
        {
            很多情况下，进程间需要通过共享某公共资源来达到写作的目的。
            这种情况下，进程必须确保它们共享的公共资源被操作系统合理地管理，且有数据一致性保证。

            这种场景下对数据的操作只需要考虑两种：
            读和写。
            其中只有写操作必须互斥。

            除了互斥问题外，还引入了一个新的问题：
            数据一致性。

            为了解决这个问题，可以将进程的整体定义一个临界区。
        }

        \subsubsection{通过通信的协作}
        {
            考虑多个进程在执行过程中相互消息，且通过通信完成同步和协作的场景。
            在该场景下，虽然进程间不再竞争使用共享资源，看起来不存在互斥问题，但死锁和饥饿问题却仍然存在。
        }
    }

    \subsection{实现互斥的条件}
    {
        支持互斥的（软硬件）机构需要满足以下条件：

        \begin{itemize}
            \item 必须达到互斥的目标：对于一个临界资源，以及访问它的临界区，一次仅允许一个进程进入临界区。
            \item 进程在非临界区的执行不能对其他进程有任何影响。
            \item 请求进入临界区的进程不能在临界区外无限等待。
            \item 如果没有进程进入临界区，任何申请进入临界区的进程都能够马上进入临界区。
            \item 不能对计算机的处理个数，或进程的相对执行速度有任何假设。
            \item 进程在自己的临界区内执行的时间必须是有限的。
        \end{itemize}

        实现互斥的方案有很多，其中一个是软件方案：
        将以上的需求全部在并发执行的进程中用代码来实现，而编程语言和操作系统不提供任何支持。
        这个方案会导致非常大的软件设计复杂度。
        另一个方案是设计一套用于并发控制的指令集，该方案导致的程序运行开销较小，但却缺乏通用性和普适性。
        第三个方案是在操作系统和编程语言上进行支持。
    }
}
