%%
%% Author: Clay
%% 2020/12/3
%%

\section{信号灯(Semaphore)}
{
    将操作系统看作是一组互相协作的串行进程。
    两个或两个以上进程的协作，可以通过简单的信号机制实现。
    进程可以在协作的关键点上等待，直到它受到特定信号后才能够继续执行。
    任何复杂的写作需求都能够通过设计合适的信号机制得以实现。

    这种信号机制所用到的数据结构被称为信号灯，它可以看作是一个特殊的整型变量。
    向信号灯发送信号，可调用\emcode{semSignal()}原语；
    从信号灯接收信号，可调用\emcode{semWait()}原语。
    如果在进程打算接收消息的时候，消息尚未到达，则该进程必须在信号灯上等待。
    信号灯及在其上进行的操作可以做以下定义：

    \begin{itemize}
        \item 信号灯的初值为非负整数。
        \item semWait操作将信号灯的值减1，如果之后它的值为负数，进程将被阻塞，否则继续执行。
        \item semSignal操作将型号等的值加1，如果之后它的值大于等于0，则进程唤醒在该信号灯上等待的一个进程，并继续自己的执行。
    \end{itemize}

    信号灯定义导致如下3个有趣的结果：

    \begin{itemize}
        \item 在进程将某信号灯的值减1前，它是不知道信号灯之前的值的，也无从知道它是否会被阻塞。
        \item 某进程将信号灯的值加1，且唤醒在该信号灯上等待的一个进程后，这两个进程将并发执行。
        \item 当进程往某信号灯上发信号时，它是不需要知道该信号灯上时候有其他进程等待的。
    \end{itemize}

    另一个类型的信号灯是01信号灯，只有两个取值：
    0和1。

    从原理上讲，01信号灯的实现比通用信号灯简单，且对进程间协作关系的表达能力与通用信号灯等同。

    另一个与01信号灯相关的概念是\emreg{互斥锁(Mutual Exclusion Lock, Mutex)}。
    互斥锁是用来控制进程对临界资源访问的可编程标识，当进程获得临界资源的访问权后会执行上锁操作，从而阻止其他进程对该临界资源的访问。
    访问完成后，进程会执行开锁操作。

    对于互斥锁而言，执行上锁和开锁的进程必须为同一个进程，对于01信号灯而言，它们可以是不同进程。

    通用信号灯和01信号灯都设计了一个队列，用来存放在其上等待的进程。
    定义进程的唤醒顺序最公平的算法是\emreg{先进先出(First In First Out, FIFO)}算法。
    将定义了这种唤醒顺序的信号灯称为\emreg{强信号灯(Strong Semaphore)}，而将未定义唤醒顺序的信号灯称为\emreg{弱信号灯(Weak Semaphore)}。

    一般来说，使用强信号灯能有效避免饥饿问题。

    \subsection{互斥的实现}
    {
        信号灯s的取值\emcode{s.count}可以这样理解：

        \begin{itemize}
            \item s.count >= 0：无需阻塞直接进入临界区的程序个数。
            \item s.count < 0：这个值的绝对值就是在s.queue 上等待信号灯的进程个数。
        \end{itemize}
    }

    \subsection{生产者/消费者问题}
    {
        \emreg{生产者/消费者问题(the Producer/Consumer Problem)}是在并发系统中最常见的问题，该问题可以表达为：有一个或多个生产者，它们不停生产数据，并将所生产的数据放到一个缓冲区中。
        同时，有一个或多个消费者将数据从缓冲区中取出，一次取一个。
        系统的限制是：
        不允许对缓冲区同时操作。
    }
}
