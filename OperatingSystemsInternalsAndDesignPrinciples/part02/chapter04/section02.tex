%%
%% Author: Clay
%% 2020/11/18
%%

\section{线程的类型}
{
    \subsection{用户级和内核级线程}
    {
        按照线程的实现方法，可以粗略地将线程分为两种：\emreg{用户级线程(User-Level Threads, ULT)}和\emreg{内核级线程(Kernel-Level Threads, KLTs)}。
        后者又被称为内核支持的线程或者轻量级进程。

        \subsubsection{用户级线程}
        {
            在纯用户级线程的设计中，所有线程管理的工作都由进程自己完成，内核甚至不知道线程的存在。

            在缺省情况下，应用进程开始执行时只有一个线程，而操作系统将该线程作为单个进程加以调度。

            与内核级线程方案相比较，采用用户级线程的方案具有以下优点。

            \begin{itemize}
                \item 由于用于管理线程的数据结构都保存在进程的用户态地址空间，线程切换无需内核态的权限，所以线程切换不需要陷入内核态以完成所有的管理工作，这就避免了两次模式切换的开销。
                \item 线程调度可由应用定制。
                \item 用户级线程可运行于任何操作系统之上。
            \end{itemize}

            与内核级线程方案相比较，采用用户级线程的方案具有以下缺点：

            \begin{itemize}
                \item 在典型的操作系统设计中，许多系统调用都会导致调用他们的进程阻塞。
                \item 在纯用户级线程的设计方案中，多线程的应用无法利用系统中的多处理器资源，这是因为操作系统一次只会将一个进程调度到一个处理器上执行。
            \end{itemize}

            这两个问题都可以通过将应用设计为多进程的方法解决。
            但是这样做抵消了采用线程所能带来的好处：
            切换必须在进程间进行，从而导致了过多的系统开销。

            避免线程阻塞的另一个办法被称为\emreg{护套(Jacketing)}技术，该技术的目标是将导致阻塞的系统调用转为非阻塞的系统调用。
        }

        \subsubsection{内核级线程}
        {
            在纯内核级线程的设计方案中，所有线程的管理功能都由操作系统来完成。
            在用户态，没有任何线程管理的代码。

            操作系统内核管理和维护所有进程及进程中线程的上下文信息。
            内核的调度算法基于系统中线程的信息。

            内核级线程设计方案的另一个优点是，操作系统自身也能够采用多线程的设计。

            相比于用户级线程方案，内核级线程方案的最大缺点在于即使是在同一进程的不同线程间切换，都会导致用户态到内核态的模式切换。
        }

        \subsubsection{混合设计}
        {
            一些操作系统提供混合用户级线程和内核级线程的设计方案，在这一方案中，线程的创建、调度和同步完全在用户态完成。
            进程的多个线程可以映射到一组内核态线程上。

            同一个应用的多个线程能同时运行在系统的多个处理器上，且某线程的阻塞不会导致整个进程的阻塞。
        }
    }

    \subsection{其他设计}
    {
        \subsubsection{多对多}
        {
            TRIX中定义了\emreg{域(Domain)}和线程的概念：
            域是一个静态实体，它由一个地址空间和用于消息发送和接收的端口组成。
            线程是一个单一的执行路径，由执行栈、处理器状态，以及调度信息所构成。

            在一个域中可以执行多个线程。
            单个用户的活动能够在多个域中执行，在这种情况下，线程还能够从一个域迁移到另一个域。
        }

        \subsubsection{一对多}
        {
            在云环境下，线程是从用户角度看到的一个活动，而进程是一个拥有进程控制块的虚拟地址空间。
            在创建后，线程从一个给定起点开始执行。
            在执行过程中，线程可以从一个地址空间迁移到另一地址空间，这种迁移甚至可以跨越机器的边界。
        }
    }
}
