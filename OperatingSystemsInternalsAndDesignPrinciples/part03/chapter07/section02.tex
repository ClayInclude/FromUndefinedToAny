%%
%% Author: Clay
%% 2020/12/8
%%

\section{内存分区}
{
    内存管理的主要操作是将进程加载到内存，使其能在处理器上执行。
    在几乎所有的现代多道程序设计系统中，该操作与一种称为虚拟内存的复杂方案密切相关。
    虚拟内存又是以分段和分页这两种基本技术或其中的一种技术为基础实现的。

    \subsection{固定分区}
    {
        操作系统占用了内存中的某些固定区域，而其余的内存区域则被多个进程使用。
        管理这些可用内存空间最简单的方法就是将其划分成多个边界固定的内存区域。
    }

    \subsection{分区大小}
    {
        使用大小相等的固定分区存在以下两个问题：

        \begin{itemize}
            \item
            {
                程序可能太大以至于不能放到一个分区中。
                此时，程序员需要利用覆盖技术来设计程序，使得在任何时候只需将程序的一部分载入内存也可正常运行。
                当需要的模块不在内存时，用户程序必须覆盖程序所在分区中的程序和数据，将该模块加载到该分区中。
            }
            {
                内存利用率非常低。
                由于载入的数据小于分区的大小，导致分区内部存在空间的浪费，这种现象称为\emspe{内部碎片(Internal Fragmentation)}。
            }
        \end{itemize}

        这两个问题可以通过使用大小不等的分区的方法来缓解，但不能完全解决。
    }

    \subsection{放置策略}
    {
        在大小相等的分区方案中，进程载入内存的位置无关紧要。
        只要有可用的内存分区，就可以将进程加载到该分区。
        由于所有分区大小相等，因此不需要考虑应该占用哪个分区。
        如果所有的分区都被无法运行的进程占用，那么需要将这些进程中的一个进程换出内存，以便为新的进程让出内存空间。

        在大小不等的分区方案中，可以采用两种不同的方法将进程加载到内存分区中。
        最简单的方法是将每个进程放到能容纳该进程的最小分区中。
        这种情况下，每个分区都需要维护一个调度队列，来保存从这个分区中换出的进程信息。
        这种方法是，总是将所有进程加载到能容纳该进程的最小分区中，从而使分区内部空间的浪费最少。

        尽管从单个分区的角度来看，这种技术是最优的，但从整个系统来看它却不是最佳的。
        需要选取一种更合适的方法，即为所有进程只提供一个队列。
        当需要加载一个进程到内存时，选择可以容纳该进程的最小可用内存分区。
        如果所有的分区都被占用，则需要交换进程。

        大小不等分区的使用能比固定分区有更多的灵活性。
        固定分区方案相对比较简单，只会产生很少的操作系统软件和处理开销，但它也存在以下两个不足之处。

        \begin{itemize}
            \item 系统生成时就已经确定了内存分区的数量，这限制了系统中活跃进程的数量。
            \item 系统生成时就已经预先设置好了分区的大小，这导致小作业不能充分利用内存分区的空间。
        \end{itemize}
    }

    \subsection{动态分区}
    {
        在动态分区中，分区的长度和个数是可以变化的。

        动态分区方法在开始时效果不错，但最终将导致在内存中出现很多容量较小的空洞。
        随着时间的推移，内存中将产生越来越多的碎片，而内存的利用率也随之下降。
        这种现象称为\emreg{外部碎片(External Fragmentation)}，指在所有分区外的内存空间中的碎片会变得越来越多。

        \emreg{压缩(Compaction)}是解决外部碎片的一种方法：
        操作系统不时地移动进程，使得进程仍然占用连续的内存空间。
        压缩的问题在于它是一个非常耗时的过程，会浪费处理器时间。
        此外，压缩需要动态重定位功能的支持。
    }

    \subsection{放置策略}
    {
        当需要将一个进程加载到或者换入到内存时，如果内存中有多个足够大的空闲内存块，操作系统需要决定将该进程放入哪个内存块中。

        可以考虑下面3中放置策略：
        最佳适应算法、首次适应算法和下次适应算法。
        最佳适应算法选取与进程大小最接近的内存块，首次适应算法从内存的起始处开始扫描内存，选取第一个能够容纳该进程的内存块，下次适应算法从上次放置进程的内存位置开始扫描内存，选取下一个能够容纳该进程的内存块。

        首次适应算法不仅简单，而且一般是最好也是最快的。
        下次适应算法的效果比首次适应算法的效果要差，它通常会在内存的尾部分配可用内存空间，这将导致内存尾部最大的空闲内存空间很快被切分成很多块容量较小的碎片，因此需要更多次的压缩解决碎片问题。
        首次适应算法会使内存的前端出现很多的小的空闲分区，在采用首次适应算法进行空闲分区检索时，都需要遍历这些分区。
        尽管最佳适应算法称为最佳，但通常它的性能是最差的。
        这个算法需要查找满足需求的最小内存块，从而使产生的碎片空间更小。
        尽管每次存储需求分配后浪费的内存空间最小，但结果是内存中很快会产生很多比较小的空闲内存块。
    }

    \subsection{置换策略}
    {
        在使用动态分区的多道程序设计系统中，有时候会出现内存中的所有进程都处于阻塞状态，同时没有足够的内存空间装入新的进程。
        为了避免因等待活动变为非阻塞状态而造成处理器时间的浪费，操作系统需要把某个阻塞的进程换出内存，以便为新的进程或处于就绪-挂起状态的进程让出内存空间。
        因此，操作系统必须选择要替换哪个进程。
    }

    \subsection{伙伴系统}
    {
        固定分区方案限制了活跃进程的数目，且当可用分区的大小与进程的大小极不匹配时，内存空间的利用率非常低。
        动态分区方案维护起来非常复杂，且存在压缩的额外开销。
        一种更有吸引力的方案就是伙伴系统。

        在伙伴系统中，内存块的大小一般为 $2^K$ 个字，且满足 $L \leq K \leq U$ ，其中：
        $2^L$ 表示分配的最小块的大小；
        $2^U$ 表示分配的最大块的大小；
        通常， $2^U$ 为可供分配的整个内存的大小。

        初始情况下，可供分配的整个空间被视为一个大小为 $2^U$ 的块。
        如果请求的大小 $s$ 满足 $2^{U - 1} \leq s \leq 2^U$ ，则将整个空间分配给它；
        否则，将该块分为两个大小相等的块。
        这个过程将一直持续，直到产生大于或等于 $s$ 的最小块，并将该块分配给该请求。
        在任何时刻，伙伴系统都维护着一个有很多洞的列表，其中每个洞的大小为 $2^i$ 。
        一个洞可以被一分为二而从列表(i + 1)中删除，并在列表(i)中创建两个大小为 $2^i$ 的伙伴。
        当列表(i)中的一对伙伴都变成未分配的块时，它们将从该列表中移除，合并成列表(i + 1)中的一个块。

        伙伴系统是一种较为合理的折中方案，它克服了固定分区和可变分区的缺陷。
    }

    \subsection{重定位}
    {
        对于大小相等的分区和不等分区的单进程队列，进程在其生命周期中可能会占用不同的分区。
        动态分区也具有相同的情况。
        此外，当内存被压缩时，进程会在内存中移动。
        因此进程访问的指令和数据的位置是不固定的，当进程每次被换入到内存或在内存中移动时，指令和数据的位置就会产生变化。
        \emreg{逻辑地址(Logical Address)}是指与当前数据在内存中的分配地址无关的访问地址，在执行内存访问之前需要将其转换成物理地址。
        \emreg{相对地址(Relative Address)}是逻辑地址的一个特例，是相对于某个已知点的地址，该点通常为处理器寄存器中的某个值。
        \emreg{物理地址(Physical Address)}或绝对地址，是数据在内存中的实际地址。

        系统采用运行时动态加载的方式把在内存中使用相对地址的程序加载到内存。
        通常情况下，被加载进程中的所有内存访问都是相对于程序的起始点的。

        当程序处于运行状态时，程序在内存中的起始地址被装入一个特殊的处理寄存器，有时也称为基址寄存器。
        还有一个界限寄存器，用于指定程序的终止位置。
        当程序被加载到内存或当该进程的映像被换入到内存时，需要对这两个寄存器的值进行设置。
        相对地址会经过处理器的两步操作：
        首先，将基址寄存器中的值与相对地址相加产生一个绝对地址；
        然后，将得到的结果与界限寄存器的值进行比较。
        如果这个地址在界限范围内，则继续该指令的执行；
        否则，将产生一个中断给操作系统，操作系统必须以某种方式对这个错误做出响应。

        该方案能让程序在执行过程中被换入和换出内存，同时还提供了保护机制：
        每个进程映像根据基址寄存器和界限寄存器的内容被隔离开来，以避免受到其它进程的非法访问。
    }
}
