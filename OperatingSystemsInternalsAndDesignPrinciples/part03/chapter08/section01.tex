%%
%% Author: Clay
%% 2020/12/9
%%

\section{硬件和控制结构}
{
    分页和分段是内存管理取得根本性突破的关键所在。

    \begin{itemize}
        \item
        {
            进程中所有的内存访问都是基于逻辑地址的，这些逻辑地址在进程执行过程中动态地转换成物理地址。
            这意味着进程可以被换入或换出内存，使得进程在执行过程中不同时刻占用不同的内存区域。
        }
        \item 进程可以被划分成许多块，动态运行时地址转换和页表或段表的使用，使得进程在执行过程中这些块不需要占用连续的内存区域。
    \end{itemize}

    如果具备前面所说的分页和分段的特点，那么进程的执行过程中，不需要将进程所有的页或段全部装入内存。
    如果存放下一条指令的块被载入内存，同时待访问的下一个数据块也在内存，则进程可以继续执行一段时间。

    用属于\emreg{块(Piece)}来表示分页机制中的页或分段机制中的段。
    假设需要将一个新进程加载到内存，操作系统仅加载一个或几个块，这一个或几个块只包含位于程序起点的部分代码及这些代码需访问的数据。
    任何时刻都存放在内存中的这部分进程称为进程的\emreg{驻留集(Resident Set)}。
    在进程的执行过程中，凡是涉及驻留集中的内存访问，都可以顺利进行。
    如果处理器发现需访问的逻辑地址不在内存，就会产生一个中断提示内存访问出错。
    此时，操作系统会将这个被中断的进程设置为阻塞状态。
    为了能让进程继续执行，操作系统必须将包含有导致访问错误的逻辑地址的进程块加载到内存。
    为此，操作系统产生一个磁盘I/O读请求。
    在磁盘的I/O执行过程中，操作系统可以调度其他进程运行。
    一旦所需的块被加载到内存，则产生一个I/O中断，将控制权交回给操作系统，然后操作系统将被阻塞的这个进程设置为就绪状态。

    提高系统利用率的方法：

    \begin{description}
        \item[内存中可以存放更多的进程]
        {
            由于任何进程都只需要加载部分块到内存，因此内存空间可以容纳更多的进程。
            这将使处理器的使用更加高效，因为在任何时刻至少都有一个进程处于就绪状态。
        }
        \item[进程可以超过整个内存的容量]
        {
            程序受内存空间的限制，这是影响程序设计的最大限制之一，但这个限制被取消了。
            对程序员来说，要处理的只是一个大容量的内存，而内存的大小与磁盘存储器有关。
        }
    \end{description}

    由于进程只能在内存中执行，因此通常内存也称为\emreg{实存(Real Memory)}。
    但程序员或用户感觉到的是一个更大的存储器，这个存储器一般配置在磁盘上，称之为\emreg{虚存(Virtual Memory)}。
    虚存支持更有效地多道程序设计，让用户从不必要的内存限制中解脱出来。

    \subsection{局部性和虚拟内存}
    {
        任何时刻每个进程只存访一部分块在内存中，那么在内存中可以容纳更多的进程。
        甚至，因为未使用的块无需换入或换出内存，从而节省了时间。
        但是，操作系统必须要能够智能地管理这个方案。
        在稳定状态下，内存空间几乎全部被进程块占用，处理器和操作系统可以直接访问尽可能多的进程。
        当操作系统需要读入一个进程块时，就需要把内存中的某个进程快换出到磁盘。
        如果换出了一块即将被使用的进程块，则操作系统不得不很快又把它换回来。
        这类操作如果太多，将导致\emreg{抖动(Thrashing)}现象：
        系统将大量的时间花费在进程块的交换上，而不是指令的执行上。

        如何避免抖动是一个重要的研究领域，出现了一些列复杂但非常有效的算法。
        本质上，这些算法都是操作系统根据最近的历史信息来猜测那些块最有可能马上被访问。

        这些决策基于\emreg{局部性原理(Principle of Locality)}进行推断。
        简单来说，局部性原理是指进程中的程序和数据访问具有聚集性趋势。

        局部性原理说明虚拟内存机制是有效的。
        为了使虚拟内存更加实用且高效，需要以下两方面的支持：
        首先，需要有对所采用的分页或分段方案的硬件支持；
        其次，需要有能在内存和辅存之间移动页和段的操作系统管理软件。
    }

    \subsection{分页}
    {
        尽管基于分段的虚拟内存也较为常见，但属于虚拟内存通常与使用分页的系统联系在一起。

        由于每个进程只有部分页在内存中，因此也标得每个表项需要有一位P来标记它所对应的页当前是否在内存中。

        页表的表项还包含一个修改位M，标记相应页的内容自上次加载到内存后有没有被修改。

        如果内容没有变化，则当需要把该页换出内存时，不需要写出该页的内容。
    }

    \subsection{页表结构}
    {
        从内存中读取一个字的基本机制包括利用页表把虚拟地址转换成物理地址。
        虚地址又称为逻辑地址，由页号和偏移量组成。
        页表的长度随着进程长度的变化而变化，因此页表不能放在寄存器中。
        它必须放在内存中，而且要能够访问。页表需占用的内存空间实在太大了。
        为了避免这个问题，大多数虚拟内存方案将页表保存在虚拟内存中 ，而不放在实际内存中。
        这意味着页表与其它页一样，都采用分页的方式进行管理。
        进程在运行的过程中，内存中必须存放有页表的一部分，这部分页表应该包含当前正在运行的页的页表项。
        一些处理器会使用二级机制来组织大型页表。
        在这类方案中，有一个页的目录，目录中每一个表项指向一个页表。

        根页表始终驻留在内存中。
        虚拟地址前几位用于检索根页表，以找到用户页表中某页对应的表项。
        如果该页不在内存中，则产生缺页中断。
        如果在内存中，则利用虚拟地址中接下来的位检索用户页表项页。

        \subsubsection{倒排页表(Inverted Page Table)}
        {
            页表的缺陷主要是页表的大小与虚拟地址空间的大小成比例增长。

            可替换的一种方案是使用一级或多级页表，并使用\emreg{倒排页表(Inverted Page Table)}结构。

            虚拟地址的页号部分通过一个简单的哈希函数映射为一个哈希值。
            页表的结构之所以称为倒排，是因为它使用页框号来检索页表项。

            页表中的每个表项都包含如下内容：

            \begin{description}
                \item[页号] 虚拟地址的页号部分
                \item[进程标识符] 拥有该页的进程
                \item[控制位] 该域包含一些标记，以及保护和锁定信息
                \item[链指针] 如果某个表项没有链接项，则表示该域为空；否则，该域包含链中下一项的索引值。
            \end{description}
        }

        \subsubsection{转换后备缓冲区(Translation Lookaside Buffer)}
        {
            原则上，每个虚拟内存的访问，会引起两次物理内存的访问：
            第一次读取相应的页表表项，第二次读取所需的数据。
            因此，如果虚拟内存机制太简单，会导致内存访问时间的加倍。
            为了避免这个问题，大多数虚拟内存机制会使用特殊的高速缓存来存储页表表项，通常称之为\emreg{转换后备缓冲区(Translation Lookaside Buffer, TLB, 有时也称为快表)}。

            处理器中的硬件机制允许处理器同时查询多个TLB表项，以确定是否存在匹配的页号。
            这个技术称为\emreg{关联映射(Associative Mapping)}。
            TLB的设计还需要考虑将哪些表项组织到TLB中，以及当需要载入新的表项时替换哪一个。

            最后，虚拟内存机制必须与高速缓存系统进行交互。
        }

        \subsubsection{页大小}
        {
            页越小，产生的内部碎片的数量就越少。
            另一方面，页越小，每个进程需要的页的数量就越大，这就意味着进程的页表就更大。
            对多道程序设计环境中的大容量进程来说，这就意味着活跃进程一部分页表可能在虚拟内存中，而不是在内存中。
            因此，一次内存访问可能产生两次缺页异常。
            另一个需要考虑的因素是大多数辅存设备的物理特性，希望页的容量能较大，这样数据块的传输会更加高效。

            页大小的设计问题海域物理内存的大小和程序的大小有关。
            当内存变大时，应用程序使用的地址空间也会变大。
            这种趋势在个人计算机和工作站上更为显著，这些机器上的应用变得越来越复杂。
            大型程序中使用的当代程序设计技术会逐渐降低进程中的局部性访问：

            \begin{itemize}
                \item 面向对象技术鼓励使用多个小程序和数据模块，这些小程序和数据模块通常在较短时间内被相对较多的对象访问
                \item 多线程应用可能导致指令流和分散的内存访问的突然变化
            \end{itemize}

            对给定大小的TLB，当进程的内存大小增加并且局部性降低时，TLB访问的命中率将降低。
            在这种情况下，TLB可能成为一个性能瓶颈。

            提高TLB新能的一种方法是使用包含更多表项、更大的TLB。
            但是，TLB的大小会影响硬件设计的其他方面，如果内存高速缓存和每个指令周期内内存访问的数量。
            一种可选的方案就是采用更大的页。

            多种页大小为TLB的有效使用提供了很大的灵活性。
        }
    }

    \subsection{分段}
    {
        \subsubsection{虚拟地址的含义}
        {
            分段让程序员把内存视为由多个地址空间或段组成。
            段的大小可以是不等的，并且可以动态变化。

            对程序员而言，这种分段的组织比非分段式地址空间有更多的优势：

            \begin{itemize}
                \item
                {
                    能够简化对不断增长的数据结构的处理。
                    如果程序员事先不知道一个特定的数据结构会变为多大，除非允许段的大小动态变化，否则猜测这个结构会会变成多大就很有必要。
                    有了基于分段的虚拟内存技术，数据结构可以分配到它自己的段操作系统可以根据需要扩大或缩小这个段。
                    如果需要扩充的段在内存中，而且没有足够的内存空间，操作系统会将这个段移到内存中一块更大的区域或把这个段换出内存。
                }
                \item 可以单独修改或重新编译程序，而不需重新链接或加载整个程序集。
                \item 有助于进程间的共享。
                \item 有助于保护。
            \end{itemize}
        }

        \subsubsection{组织}
        {
            通常每个进程拥有一个唯一的的段表。
            由于一个进程可能只有一部分段在内存中，因而每个段表项中需要有一位来表示相应的段是否在内存中。
            如果这一位标识该段在内存中，则该表项中还包含该段的起始地址和长度。

            段表项中的另一个控制位是修改位，用于标识相应段的内容自上次加载到内存后有没有被修改。
            如果内容没有变化，则把该段换出内存时就不需要写回。
            可能还会有其他的控制位。

            从内存中的读取一个字的基本机制涉及使用段表将由段号和偏移量组成的虚地址转换成物理地址。

            虚地址中的段号用于检索该表，并查找该段存放在内存中的起始地址。
            这个地址加上虚拟地址中的偏移量部分，就产生了所需的实际地址。
        }
    }

    \subsection{段页式}
    {
        在段页式系统中，用户地址空间被程序员划分成多个段，每个段依次划分成许多大小固定的页，其长度等于内存页框的长度。
        如果某个段的长度小于一页，则只占用一页。
        从程序员的角度来看，逻辑地址仍然由段号和段偏移量组成；
        而从系统的角度来看，段偏移量可视为段中的页号和页偏移量。

        对每一个虚地址，处理器利用段号部分检索进程段表，查找该段对应的页表。
        然后根据虚地址的页号部分检索页表，查找相应的页框号。
        将其与虚地址中的偏移量部分相结合，就产生了所需的实地址。
    }

    \subsection{保护和共享}
    {
        分段有助于实现保护和共享机制。
        由于每个段表项包含长度和及地址，因此程序不可能不经意地访问超出该段的内存单元。
        为了实现共享，一个段可能在多个进程的段表中被引用。

        环状系统的基本原理如下：

        \begin{itemize}
            \item 程序只能访问驻留在同一个或特权更低的环中的数据。
            \item 程序可以调用驻留在同一个或具有更多特权的环中的服务。
        \end{itemize}
    }
}
