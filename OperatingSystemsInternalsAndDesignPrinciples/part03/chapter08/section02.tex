%%
%% Author: Clay
%% 2020/12/11
%%

\section{操作系统软件}
{
    操作系统中内存管理的设计取决于以下3个方面的选择：

    \begin{itemize}
        \item 是否使用虚拟内存技术
        \item 使用分页还是分段，或是二者的结合
        \item 为实现各种内存管理功能采用的算法
    \end{itemize}

    前两方面的选择取决于使用的硬件平台。
    如果没有地址转换和其他基本功能的硬件支持，分页和分段技术都是不可能真正实用的。

    针对前两方面给出两个附加的建议：
    首先，除了一些老式个人计算机上的操作系统和专用系统之外，几乎所有操作系统都提供了虚拟内存的功能；
    其次，几乎没有存粹的分段系统。
    当分段与分页相结合后，操作系统设计者面临的大多数内存管理问题都来源于分页。

    第3方面的选择属于操作系统软件领域的问题。
    在各种情况下，最关键的问题就是性能：
    由于缺页带来的巨大的软件开销，所以希望尽可能减少缺页率。

    分页环境中的内存管理任务是极其复杂的。
    此外，任何一个策略集的性能取决于内存的大小、内存和辅存的相对速度、竞争使用资源的进程的大小和数量，以及单个程序的执行行为。

    对小型系统，操作系统设计者可以基于当前状态信息，尝试选择一组看上去在大多数条件都比较好的策略。
    而对大型系统，尤其是大型机，操作系统应该配被监视和监控工具，允许系统管理员根据系统状态调整操作系统。

    \subsection{读取策略}
    {
        读取策略用于确定将页读入内存的时机，常用的两种可选方案是\emreg{请求分页(Demand Paging)}和\emreg{预分页(Prepaging)}。
        对于请求分页，只有当访问某页中的单元时，才将该页加载到内存。
        如果采用合适的内存管理策略，将会发生以下情况：
        当进程第一次开始执行时，会出现大量的缺页中断。
        根据局部性原理，一段时间后，缺页异常会逐渐减少。

        对于预分页，加载到内存的页并不是缺页请求时请求的页。
        预分页利用大多数辅存设备的特性，一次读取许多连续的页比隔一段时间读取一页更加有效。
    }

    \subsection{放置策略}
    {
        在一个纯粹的分段系统中，放置策略是一个非常重要的设计问题。
        对于纯粹的分页系统或段页式系统来说，放置到哪里通常是无关紧要的。

        在所谓的\emreg{非一致存储访问(Nonuniform Memory Access), NUMA}多处理器中，机器中的分布式共享内存可以被任何一个处理器访问，但是访问某一特定物理单元的时间随着处理器与内存模块之间距离的不同而变化。
        其性能很大程度依赖于数据驻留的位置与使用该数据的处理器之间的距离。
    }

    \subsection{置换策略}
    {
        在需要加载新的一页到内存时，应该选取内存中的哪一页置换出去。
        主要包括：

        \begin{itemize}
            \item 给每个活跃进程分配了多少页框
            \item 计划置换的那一组页是限制在产生缺页中断的进程内，还是可以包括内存中所有的页框
            \item 在计划置换的那一组页中，选择换出哪一个页
        \end{itemize}

        前两个概念称为\emreg{驻留集管理(Resident Set Management)}，术语\emreg{置换策略(Replacement Policy)}专指第三个概念。

        置换策略在内存管理的各个领域都得到了广泛的研究。
        所有策略的目标都是置换最近最不可能被访问的那一页。
        根据局部性原理，最近访问的历史信息与最近将要访问的模式之间具有较大的关联性，因此，大多数策略都基于过去的行为预测将来的行为。

        \paraph{页框锁定(Frame Locking)}
        {
            内存中的一些页框可能会被锁定。
            当某个页框被锁定时，当前存放在该页框中的页不会被置换。
            很多操作系统的内核和重要的控制结构都保存在锁定的页框中。
            I/O缓冲区和其它时间要求严格的区域也会被锁到内存的页框中。
            锁定是通过给每个页框关联一个锁位来实现的，这个锁位可以保存在页框表中，也可以包含在当前页表中。
        }

        \paraph{基本算法}
        {
            不论采用哪种驻留集管理策略，都有一些用于选择置换哪一页的基本算法：

            \begin{itemize}
                \item 最佳(Optimal)
                \item 最近最少使用(Least Recently Used, LRU)
                \item 先进先出
                \item 时钟(Clock)
            \end{itemize}
        }

        \emreg{最佳策略}选择下次发给你问时间距当前时间最长的那一页。
        显然，这种策略是不可能实现的，因为它要求操作系统准确的预知未来的事件。

        \emreg{最近最少使用(LRU)}策略将页放置在最长时间没有被访问的内存单元。
        LRU策略的性能接近于最佳策略。
        该方法的问题是实现起来比较困难。
        一种方法是给每个页添加最后一次访问该页的时间的标识。
        另一种可替代的方法是维护一个被访问页的栈。

        \emreg{先进先出(FIFO)}策略把分配给进程的页框视为一个循环缓冲区，采用循环轮转的方式移动页。
        该策略只需要一个能在该进程的页框中轮转的指针。
    }

    \subsection{页缓冲}
    {
        以重既能提高分页性能又能使用较简单的页面置换策略的方法就是页缓冲。
        比较有代表性的是VAX VMS方法，它使用简单的FIFO作为页面置换算法。
        为了提升性能，被置换的页不被淘汰，而是被分配到两个列表中的一个：
        如果该页没有被修改，则将其放入空闲页列表；
        如果被修改，则放入修改页列表。
    }

    \subsection{置换策略和高速缓存的大小}
    {
        通过为页面置换策略补充页缓冲中的页面放置策略可以提高高速缓存的性能。

        \paraph{驻留集大小}
        {
            操作系统必须决定为该进程分配多大的内存：

            \begin{itemize}
                \item 分给进程的内存越小，任何时刻驻留在内存中的进程数就越多
                \item 如果进程在内存中的页数比较少，缺页率会比较高
                \item 当分配给某进程的内存空间超出一定的大小后，由于局部性原理，该进程的缺页率将不会有明显变化。
            \end{itemize}

            基于这些因素，现代操作系统中通常采用两种策略。
            \emreg{固定分配(Fixed-Allocation)}策略为执行的进程在内存中分配固定数目的页框，该数目在最初加载时确定。
            对于固定分配策略，一旦进程在在执行过程中产生了缺页异常，该进程的一页必须与需加载的页面置换。

            \emreg{可变分配(Variable-Allocation)}策略允许分配给进程的页框在进程的生命周期内动态变化。

            可变分配策略看起来性能更优，但是，使用这种方法的困难在于需要操作系统能评估活动进程的行为。
        }

        \paraph{置换范围}
        {
            置换策略的作用范围可以分为全局和局部两类。
            这两类策略都在没有空闲页框时由缺页中断激活。
            \emreg{局部置换策略(Local Replacement Policy)}在产生缺页异常的进程的驻留页中选择一页进行置换。
            \emreg{全局置换策略(Global Replacement Policy)}把内存中所有未被锁定的页作为置换的候选页，而不管它们属于哪个进程。
        }

        \paraph{固定分配，局部范围}
        {
            这种情况下，内存中运行的进程分配的页框时固定的。
            当产生缺页异常时，操作系统从该进程当前的驻留页中选择一项置换。
        }

        \paraph{可变分配，全局范围}
        {
            任何时刻，内存中都存在大量的进程，每个进程都分配了一定数目的页框。
            通常，操作系统会维护一个空闲页框的列表。
            当产生缺页异常时，在进程的驻留集中增加一个空闲页框，并载入该页。

            这种方法的难点在于置换页的选取。
            当没有可用的空闲页框时，操作系统需要在内存中选择一个未被锁定的页框。
        }

        \paraph{可变分配，局部范围}
        {
            该策略可以总结如下：

            \begin{enumerate}
                \item 当加载新进程到内存时，根据应用类型、程序要求或其他原则为该进程分配一定数目的页框作为驻留集。
                \item 当产生缺页异常时，从产生该异常的进程驻留集中选择一页进行置换。
                \item 不时地重新评估该进程的分配情况，增加或减少分配给它的页框数，以提高整体性能。
            \end{enumerate}
        }
    }

    \subsection{清除策略}
    {
        清除策略与读取策略正好相反，它用于确定被修改的页写回辅存的时机，通常只有两种选择：
        请求清除和预清除。
        对于\emreg{请求清除(Demand Cleaning)}，只有当某页被选择用于置换时才将其写回到辅存。
        \emreg{预清除(Precleaning)}策略在被修改的页所在的页框需要使用之前执行页的写回操作。

        一种比较好的方法是与页缓冲结合。
    }

    \subsection{加载控制}
    {
        加载控制关注的是驻留在内存中的进程数（称之为系统并发度）。
        如果某时刻驻留的进程太少，则所有进程被阻塞的概率会非常大，同时需要花费大量的时间在交换上。
        如果驻留的进程太多，每个进程驻留集的平均大小不够用，会频繁的产生缺页异常，从而导致抖动。

        \subsubsection{并发度}
        {
            当系统并发度从一个较小的值开始增加时，可以看到处理器的利用率逐渐增大，这是因为很少出现所有驻留进程都被阻塞的情况。
            但是，当达到某一点时，平均驻留集会不够用，此时缺页异常数急剧增加，处理器的利用率也会下降。
        }

        \subsubsection{进程挂起}
        {
            如果减小系统的并发度，那么需要挂起当前的一个或多个驻留进程。

            \begin{description}
                \item[最低优先级进程] 实现调度策略的决策，并且与性能问题无关
                \item[缺页进程] 缺页任务的工作集没有驻留的可能性很大
                \item[最后被激活的进程] 这个进程的工作集最有可能没有驻留
                \item[驻留集最小的进程] 将来再次装入所需的代价最小
                \item[最大的进程] 可以从过量使用的内存中得到最多的空闲页框，从而不会很快又处于去活状态
                \item[具有最大剩余执行窗口的进程] 进程在被中断并放至就绪队列尾部之前只运行一定的时间
            \end{description}
        }
    }
}
