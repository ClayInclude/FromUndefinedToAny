%%
%% Author: Clay
%% 2020/12/14
%%

\section{复习题}
{
    %1.
    \begin{reviewc}
        内存中可以存放更多的进程，进程可以超过整个内存的容量。
    \end{reviewc}

    %2.
    \begin{reviewc}
        系统将大量的时间花费在进程块的交换上，而不是指令的执行上。
    \end{reviewc}

    %3.
    \begin{reviewc}
        在很短时间内只需要少量的进程块的假设是成立的，同时可以对即将访问哪个进程块进行预测，从而避免系统抖动。
    \end{reviewc}

    %4.
    \begin{reviewc}
        内部碎片、页表大小、缺页率。
    \end{reviewc}

    %5.
    \begin{reviewc}
        每个虚拟内存的访问会引起两次物理内存的访问。
        为了避免这个问题，大多数虚拟内存机制会使用特殊的高速缓存来存储页表表项。
    \end{reviewc}

    %6.
    \begin{reviewc}
        只有当访问某页中的单元时，才将该页加载到内存。
    \end{reviewc}

    %7.
    \begin{reviewc}
        预清除允许批量写回页，但如果在写回后，发现其中大部分页被修改过了，那就没有太大意义了。
        请求清除意味着产生缺页异常的进程在解除阻塞之前不得不等待两次页的传输。
    \end{reviewc}

    %8.
    \begin{reviewc}
        两者类似，但时钟置换算法跳过了标记位正在使用的页。
    \end{reviewc}

    %9.
    \begin{reviewc}
        加载新的一页到内存。
    \end{reviewc}

    %10.
    \begin{reviewc}
        固定策略中，分配给进程的页框是固定的，即使置换出了其它进程的页，也无法使用。
    \end{reviewc}

    %11.
    \begin{reviewc}
        工作集是指进程已映射的物理内存部分。
        驻留集，是指在某段时间间隔内，进程要访问的页面集合。
    \end{reviewc}

    %12.
    \begin{reviewc}
        请求清除只有当某页用于置换时才写回辅存。
        预清除在被修改的页需要使用之前执行写回。
    \end{reviewc}
}
